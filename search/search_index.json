{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"/]+|(?!\\b)(?=[A-Z][a-z])|\\.(?!\\d)|&[lg]t;","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"JFChemistry","text":"<p>A comprehensive computational chemistry workflow package built on jobflow.</p>"},{"location":"#overview","title":"Overview","text":"<p>JFChemistry provides a flexible framework for building computational chemistry workflows using various methods ranging from force fields to machine learning potentials. It seamlessly integrates with popular chemistry libraries like RDKit, ASE, and Pymatgen.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Structure Generation: Create 3D molecular structures from SMILES strings or PubChem database</li> <li>Conformer Search: Generate and optimize multiple conformers using RDKit and CREST</li> <li>Geometry Optimization: Optimize structures with multiple methods (GFN-xTB, AimNet2, ORB models)</li> <li>Structure Modification: Perform protonation/deprotonation using CREST</li> <li>Workflow Management: Build complex, parallelizable workflows with jobflow</li> <li>Multiple Calculators: Support for ASE, TBLite, AimNet2, and ORB machine learning potentials</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>The package uses Pixi for dependency management:</p> <pre><code># Clone the repository\ngit clone https://github.com/cfarm6/jfchemistry.git\ncd jfchemistry\n\n# Install with pixi\npixi install\n\n# For development\npixi install -e dev\n\n# For AimNet2 support\npixi install -e aimnet2\n\n# For ORB model support\npixi install -e orb\n\n# For documentation\npixi install -e docs\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Here's a simple workflow to create a molecule from SMILES, generate conformers, and optimize:</p> <pre><code>from jfchemistry.inputs import Smiles\nfrom jfchemistry.generation import RDKitGeneration\nfrom jfchemistry.optimizers import TBLiteOptimizer\n\n# Create molecule from SMILES\nsmiles_maker = Smiles(add_hydrogens=True)\nsmiles_job = smiles_maker.make(\"CCO\")  # Ethanol\n\n# Generate 3D conformers\ngenerator = RDKitGeneration(num_conformers=10, method=\"ETKDGv3\")\ngen_job = generator.make(smiles_job.output[\"structure\"])\n\n# Optimize with GFN2-xTB\noptimizer = TBLiteOptimizer(method=\"GFN2-xTB\", fmax=0.01)\nopt_job = optimizer.make(gen_job.output[\"structure\"])\n\n# Access results\noptimized_structures = opt_job.output[\"structure\"]\nproperties = opt_job.output[\"properties\"]\n</code></pre>"},{"location":"#architecture","title":"Architecture","text":"<p>JFChemistry is built around two main base classes:</p> <ul> <li>SingleMoleculeMaker: For operations on molecules without 3D coordinates (RDKit molecules)</li> <li>SingleStructureMaker: For operations on structures with 3D coordinates (Pymatgen structures)</li> </ul> <p>These base classes automatically handle:</p> <ul> <li>Job distribution for lists of structures</li> <li>Parallel processing of multiple conformers</li> <li>Consistent output formats across different methods</li> </ul>"},{"location":"#modules","title":"Modules","text":"<ul> <li>Inputs: Create molecules from SMILES, PubChem CID</li> <li>Generation: Generate 3D structures from molecular graphs</li> <li>Conformers: Search conformational space with CREST</li> <li>Optimizers: Optimize geometries with various methods</li> <li>Calculators: Set up and run energy/property calculations</li> <li>Modification: Modify structures (protonation, deprotonation)</li> <li>Base Classes: Core framework classes</li> </ul>"},{"location":"#credits","title":"Credits","text":"<p>This package was created with Cookiecutter and the jevandezande/pixi-cookiecutter project template.</p>"},{"location":"base_nodes/","title":"Base Nodes","text":"<p>The base nodes provide the core framework for building computational chemistry workflows. All workflow components in jfchemistry inherit from these base classes.</p>"},{"location":"base_nodes/#rdmolmolecule","title":"RDMolMolecule","text":"<p>handler: python options: show_root_heading: true show_source: true members: - as_dict - from_dict</p>"},{"location":"base_nodes/#jfchemistry.jfchemistry.RDMolMolecule","title":"RDMolMolecule","text":"<p>               Bases: <code>Mol</code></p> <p>RDKit molecule wrapper with serialization support.</p> <p>This class extends RDKit's Mol class to provide serialization capabilities for use in jobflow workflows. It enables molecules to be stored in databases and passed between workflow jobs.</p> <p>The class uses pickle serialization to convert RDKit molecules to/from dictionary representations compatible with MongoDB and other document stores.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from rdkit import Chem\n&gt;&gt;&gt; from jfchemistry import RDMolMolecule\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Create from SMILES\n&gt;&gt;&gt; mol = Chem.MolFromSmiles(\"CCO\")\n&gt;&gt;&gt; rdmol = RDMolMolecule(mol)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Serialize to dictionary\n&gt;&gt;&gt; mol_dict = rdmol.as_dict()\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Deserialize from dictionary\n&gt;&gt;&gt; restored_mol = RDMolMolecule.from_dict(mol_dict)\n</code></pre>"},{"location":"base_nodes/#jfchemistry.jfchemistry.RDMolMolecule-functions","title":"Functions","text":""},{"location":"base_nodes/#jfchemistry.jfchemistry.RDMolMolecule.as_dict","title":"as_dict","text":"<pre><code>as_dict() -&gt; dict[str, Any]\n</code></pre> <p>Convert the molecule to a dictionary representation.</p> <p>Serializes the RDKit molecule using pickle and stores it in a dictionary format suitable for storage in MongoDB or other document databases.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary containing the serialized molecule with module and class</p> <code>dict[str, Any]</code> <p>metadata for reconstruction.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from rdkit import Chem\n&gt;&gt;&gt; from jfchemistry import RDMolMolecule\n&gt;&gt;&gt; mol = RDMolMolecule(Chem.MolFromSmiles(\"CCO\"))\n&gt;&gt;&gt; mol_dict = mol.as_dict()\n&gt;&gt;&gt; print(mol_dict.keys())\ndict_keys(['@module', '@class', 'data'])\n</code></pre> Source code in <code>jfchemistry/jfchemistry.py</code> <pre><code>def as_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Convert the molecule to a dictionary representation.\n\n    Serializes the RDKit molecule using pickle and stores it in a dictionary\n    format suitable for storage in MongoDB or other document databases.\n\n    Returns:\n        Dictionary containing the serialized molecule with module and class\n        metadata for reconstruction.\n\n    Examples:\n        &gt;&gt;&gt; from rdkit import Chem\n        &gt;&gt;&gt; from jfchemistry import RDMolMolecule\n        &gt;&gt;&gt; mol = RDMolMolecule(Chem.MolFromSmiles(\"CCO\"))\n        &gt;&gt;&gt; mol_dict = mol.as_dict()\n        &gt;&gt;&gt; print(mol_dict.keys())\n        dict_keys(['@module', '@class', 'data'])\n    \"\"\"\n    d = {\n        \"@module\": self.__class__.__module__,\n        \"@class\": self.__class__.__name__,\n        \"data\": pickle.dumps(super()),\n    }\n    return d\n</code></pre>"},{"location":"base_nodes/#jfchemistry.jfchemistry.RDMolMolecule.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(d: dict[str, Any]) -&gt; Any\n</code></pre> <p>Reconstruct a molecule from a dictionary representation.</p> <p>Deserializes an RDMolMolecule from a dictionary created by as_dict(). Handles both string and bytes representations of pickled data.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>dict[str, Any]</code> <p>Dictionary containing serialized molecule data with '@module', '@class', and 'data' keys.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>RDMolMolecule instance reconstructed from the dictionary.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from rdkit import Chem\n&gt;&gt;&gt; from jfchemistry import RDMolMolecule\n&gt;&gt;&gt; mol = RDMolMolecule(Chem.MolFromSmiles(\"CCO\"))\n&gt;&gt;&gt; mol_dict = mol.as_dict()\n&gt;&gt;&gt; restored_mol = RDMolMolecule.from_dict(mol_dict)\n&gt;&gt;&gt; Chem.MolToSmiles(restored_mol)\n'CCO'\n</code></pre> Source code in <code>jfchemistry/jfchemistry.py</code> <pre><code>@classmethod\ndef from_dict(cls, d: dict[str, Any]) -&gt; Any:\n    \"\"\"Reconstruct a molecule from a dictionary representation.\n\n    Deserializes an RDMolMolecule from a dictionary created by as_dict().\n    Handles both string and bytes representations of pickled data.\n\n    Args:\n        d: Dictionary containing serialized molecule data with '@module',\n            '@class', and 'data' keys.\n\n    Returns:\n        RDMolMolecule instance reconstructed from the dictionary.\n\n    Examples:\n        &gt;&gt;&gt; from rdkit import Chem\n        &gt;&gt;&gt; from jfchemistry import RDMolMolecule\n        &gt;&gt;&gt; mol = RDMolMolecule(Chem.MolFromSmiles(\"CCO\"))\n        &gt;&gt;&gt; mol_dict = mol.as_dict()\n        &gt;&gt;&gt; restored_mol = RDMolMolecule.from_dict(mol_dict)\n        &gt;&gt;&gt; Chem.MolToSmiles(restored_mol)\n        'CCO'\n    \"\"\"\n    if type(d[\"data\"]) is str:\n        return pickle.loads(eval(d[\"data\"]))\n    else:\n        return pickle.loads(d[\"data\"])\n</code></pre>"},{"location":"base_nodes/#singlemoleculemaker","title":"SingleMoleculeMaker","text":"<p>handler: python options: show_root_heading: true show_source: true members: - make - operation</p>"},{"location":"base_nodes/#jfchemistry.jfchemistry.SingleMoleculeMaker","title":"SingleMoleculeMaker  <code>dataclass</code>","text":"<pre><code>SingleMoleculeMaker(name: str = 'Single RDMolMolecule Maker')\n</code></pre> <p>               Bases: <code>Maker</code></p> <p>Base class for operations on molecules without 3D geometry.</p> <p>This Maker processes RDMolMolecule objects that do not yet have assigned 3D coordinates. It is primarily used for structure generation tasks that convert molecular representations (SMILES, SMARTS) into 3D structures.</p> <p>The class handles automatic job distribution for lists of molecules and molecules with multiple conformers, enabling parallel processing of multiple structures.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Descriptive name for the job/operation being performed.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from jfchemistry.inputs import Smiles\n&gt;&gt;&gt; from jfchemistry.generation import RDKitGeneration\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Get molecule from SMILES\n&gt;&gt;&gt; smiles_maker = Smiles()\n&gt;&gt;&gt; smiles_job = smiles_maker.make(\"CCO\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Generate 3D structures\n&gt;&gt;&gt; generator = RDKitGeneration(num_conformers=10, method=\"ETKDGv3\")\n&gt;&gt;&gt; gen_job = generator.make(smiles_job.output[\"structure\"])\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Access generated structures\n&gt;&gt;&gt; structures = gen_job.output[\"structure\"]  # List of Molecule objects\n</code></pre>"},{"location":"base_nodes/#jfchemistry.jfchemistry.SingleMoleculeMaker-functions","title":"Functions","text":""},{"location":"base_nodes/#jfchemistry.jfchemistry.SingleMoleculeMaker.make","title":"make","text":"<pre><code>make(molecule: RDMolMolecule | list[RDMolMolecule]) -&gt; Response[dict[str, Any]]\n</code></pre> <p>Create a workflow job for processing molecule(s).</p> <p>Automatically handles job distribution for lists of molecules and for molecules with multiple conformers. Each molecule or conformer is processed as a separate job for parallel execution.</p> <p>Parameters:</p> Name Type Description Default <code>molecule</code> <code>RDMolMolecule | list[RDMolMolecule]</code> <p>Single RDMolMolecule or list of RDMolMolecule objects.</p> required <p>Returns:</p> Type Description <code>Response[dict[str, Any]]</code> <p>Response containing: - structure: Generated structure(s) as Pymatgen objects - files: MOL format file(s) of the structure(s) - properties: Computed properties from the operation</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from jfchemistry.generation import RDKitGeneration\n&gt;&gt;&gt; from rdkit import Chem\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Create RDKit molecule\n&gt;&gt;&gt; mol = Chem.MolFromSmiles(\"c1ccccc1\")\n&gt;&gt;&gt; rdmol = RDMolMolecule(mol)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Generate multiple conformers\n&gt;&gt;&gt; gen = RDKitGeneration(num_conformers=50)\n&gt;&gt;&gt; job = gen.make(rdmol)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Each conformer becomes a separate structure\n&gt;&gt;&gt; conformers = job.output[\"structure\"]\n</code></pre> Source code in <code>jfchemistry/jfchemistry.py</code> <pre><code>@job(files=\"files\", properties=\"properties\")\ndef make(\n    self,\n    molecule: RDMolMolecule | list[RDMolMolecule],\n) -&gt; Response[dict[str, Any]]:\n    \"\"\"Create a workflow job for processing molecule(s).\n\n    Automatically handles job distribution for lists of molecules and for\n    molecules with multiple conformers. Each molecule or conformer is\n    processed as a separate job for parallel execution.\n\n    Args:\n        molecule: Single RDMolMolecule or list of RDMolMolecule objects.\n\n    Returns:\n        Response containing:\n            - structure: Generated structure(s) as Pymatgen objects\n            - files: MOL format file(s) of the structure(s)\n            - properties: Computed properties from the operation\n\n    Examples:\n        &gt;&gt;&gt; from jfchemistry.generation import RDKitGeneration\n        &gt;&gt;&gt; from rdkit import Chem\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Create RDKit molecule\n        &gt;&gt;&gt; mol = Chem.MolFromSmiles(\"c1ccccc1\")\n        &gt;&gt;&gt; rdmol = RDMolMolecule(mol)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Generate multiple conformers\n        &gt;&gt;&gt; gen = RDKitGeneration(num_conformers=50)\n        &gt;&gt;&gt; job = gen.make(rdmol)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Each conformer becomes a separate structure\n        &gt;&gt;&gt; conformers = job.output[\"structure\"]\n    \"\"\"\n    resp = handle_molecules(self, molecule)\n    if resp is not None:\n        return resp\n    else:  # If the structure is not a list, generate a single structure\n        molecule, properties = self.operation(cast(\"RDMolMolecule\", molecule))\n        if type(molecule) is list:\n            files = [m.to(fmt=\"mol\") for m in molecule]\n        else:\n            files = [molecule.to(fmt=\"mol\")]\n        return Response(\n            output={\n                \"structure\": molecule,\n                \"files\": files,\n                \"properties\": properties,\n            }\n        )\n</code></pre>"},{"location":"base_nodes/#jfchemistry.jfchemistry.SingleMoleculeMaker.operation","title":"operation","text":"<pre><code>operation(mol: RDMolMolecule) -&gt; tuple[SiteCollection | list[SiteCollection], dict[str, Any]]\n</code></pre> <p>Perform the computational operation on a molecule.</p> <p>This method must be implemented by subclasses to define the specific operation to perform (e.g., 3D structure generation, conformer embedding).</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>RDMolMolecule</code> <p>RDMolMolecule to perform the operation on.</p> required <p>Returns:</p> Type Description <code>tuple[SiteCollection | list[SiteCollection], dict[str, Any]]</code> <p>Tuple containing: - Generated structure(s) as Pymatgen SiteCollection(s) - Dictionary of properties from the operation</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>This method must be implemented by subclasses.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # In a subclass implementation\n&gt;&gt;&gt; def operation(self, mol: RDMolMolecule):\n...     # Generate 3D structure\n...     structure = generate_3d_structure(mol)\n...     properties = {\"energy\": -123.45}\n...     return structure, properties\n</code></pre> Source code in <code>jfchemistry/jfchemistry.py</code> <pre><code>def operation(\n    self, mol: RDMolMolecule\n) -&gt; tuple[SiteCollection | list[SiteCollection], dict[str, Any]]:\n    \"\"\"Perform the computational operation on a molecule.\n\n    This method must be implemented by subclasses to define the specific\n    operation to perform (e.g., 3D structure generation, conformer embedding).\n\n    Args:\n        mol: RDMolMolecule to perform the operation on.\n\n    Returns:\n        Tuple containing:\n            - Generated structure(s) as Pymatgen SiteCollection(s)\n            - Dictionary of properties from the operation\n\n    Raises:\n        NotImplementedError: This method must be implemented by subclasses.\n\n    Examples:\n        &gt;&gt;&gt; # In a subclass implementation\n        &gt;&gt;&gt; def operation(self, mol: RDMolMolecule):\n        ...     # Generate 3D structure\n        ...     structure = generate_3d_structure(mol)\n        ...     properties = {\"energy\": -123.45}\n        ...     return structure, properties\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"base_nodes/#singlestructuremaker","title":"SingleStructureMaker","text":"<p>handler: python options: show_root_heading: true show_source: true members: - make - operation</p>"},{"location":"base_nodes/#jfchemistry.jfchemistry.SingleStructureMaker","title":"SingleStructureMaker  <code>dataclass</code>","text":"<pre><code>SingleStructureMaker(name: str = 'Single Structure Maker')\n</code></pre> <p>               Bases: <code>Maker</code></p> <p>Base class for operations on structures with 3D geometry.</p> <p>This Maker processes Pymatgen SiteCollection objects (Molecule or Structure) that have assigned 3D coordinates. It handles automatic job distribution for lists of structures and provides a common interface for geometry optimization, conformer generation, and structure modifications.</p> <p>Subclasses should implement the operation() method to define specific computational tasks such as geometry optimization, property calculation, or structure modification.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Descriptive name for the job/operation being performed.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from jfchemistry.optimizers import TBLiteOptimizer\n&gt;&gt;&gt; from pymatgen.core import Molecule\n&gt;&gt;&gt; from ase.build import molecule\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Create an optimizer\n&gt;&gt;&gt; optimizer = TBLiteOptimizer(method=\"GFN2-xTB\", fmax=0.01)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Optimize a single structure\n&gt;&gt;&gt; mol = Molecule.from_ase_atoms(molecule(\"H2O\"))\n&gt;&gt;&gt; job = optimizer.make(mol)\n&gt;&gt;&gt; optimized_mol = job.output[\"structure\"]\n&gt;&gt;&gt; energy = job.output[\"properties\"][\"Global\"][\"Total Energy [Eh]\"]\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Optimize multiple structures in parallel\n&gt;&gt;&gt; ethanol = Molecule.from_ase_atoms(molecule(\"C2H5OH\"))\n&gt;&gt;&gt; methane = Molecule.from_ase_atoms(molecule(\"CH4\"))\n&gt;&gt;&gt; water = Molecule.from_ase_atoms(molecule(\"H2O\"))\n&gt;&gt;&gt; job = optimizer.make([ethanol, methane, water])\n&gt;&gt;&gt; # Returns list of optimized structures\n&gt;&gt;&gt; optimized_structures = job.output[\"structure\"]\n</code></pre>"},{"location":"base_nodes/#jfchemistry.jfchemistry.SingleStructureMaker-functions","title":"Functions","text":""},{"location":"base_nodes/#jfchemistry.jfchemistry.SingleStructureMaker.make","title":"make","text":"<pre><code>make(structure: SiteCollection | list[SiteCollection]) -&gt; Response[dict[str, Any]]\n</code></pre> <p>Create a workflow job for processing structure(s).</p> <p>Automatically handles job distribution for lists of structures. Each structure in a list is processed as a separate job for parallel execution.</p> <p>Parameters:</p> Name Type Description Default <code>structure</code> <code>SiteCollection | list[SiteCollection]</code> <p>Single Pymatgen SiteCollection or list of SiteCollections.</p> required <p>Returns:</p> Type Description <code>Response[dict[str, Any]]</code> <p>Response containing: - structure: Processed structure(s) - files: XYZ format file(s) of the structure(s) - properties: Computed properties from the operation</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from jfchemistry.conformers import CRESTConformers\n&gt;&gt;&gt; from pymatgen.core import Molecule\n&gt;&gt;&gt; molecule = Molecule.from_ase_atoms(molecule(\"C2H6\"))\n&gt;&gt;&gt; # Generate conformers\n&gt;&gt;&gt; conformer_gen = CRESTConformers(ewin=6.0)\n&gt;&gt;&gt; job = conformer_gen.make(molecule)\n</code></pre> Source code in <code>jfchemistry/jfchemistry.py</code> <pre><code>@job(files=\"files\", properties=\"properties\")\ndef make(\n    self,\n    structure: SiteCollection | list[SiteCollection],\n) -&gt; Response[dict[str, Any]]:\n    \"\"\"Create a workflow job for processing structure(s).\n\n    Automatically handles job distribution for lists of structures. Each\n    structure in a list is processed as a separate job for parallel execution.\n\n    Args:\n        structure: Single Pymatgen SiteCollection or list of SiteCollections.\n\n    Returns:\n        Response containing:\n            - structure: Processed structure(s)\n            - files: XYZ format file(s) of the structure(s)\n            - properties: Computed properties from the operation\n\n    Examples:\n        &gt;&gt;&gt; from jfchemistry.conformers import CRESTConformers # doctest: +SKIP\n        &gt;&gt;&gt; from pymatgen.core import Molecule # doctest: +SKIP\n        &gt;&gt;&gt; molecule = Molecule.from_ase_atoms(molecule(\"C2H6\")) # doctest: +SKIP\n        &gt;&gt;&gt; # Generate conformers\n        &gt;&gt;&gt; conformer_gen = CRESTConformers(ewin=6.0) # doctest: +SKIP\n        &gt;&gt;&gt; job = conformer_gen.make(molecule) # doctest: +SKIP\n    \"\"\"\n    resp = handle_structures(self, structure)\n    if resp is not None:\n        return resp\n    else:  # If the structure is not a list, generate a single structure\n        structures, properties = self.operation(cast(\"SiteCollection\", structure))\n        if type(structures) is list:\n            files = [s.to(fmt=\"xyz\") for s in structures]\n        else:\n            files = [structures.to(fmt=\"xyz\")]\n        return Response(\n            output={\n                \"structure\": structures,\n                \"files\": files,\n                \"properties\": properties,\n            }\n        )\n</code></pre>"},{"location":"base_nodes/#jfchemistry.jfchemistry.SingleStructureMaker.operation","title":"operation","text":"<pre><code>operation(structure: SiteCollection) -&gt; tuple[SiteCollection | list[SiteCollection], Optional[dict[str, Any]]]\n</code></pre> <p>Perform the computational operation on a structure.</p> <p>This method must be implemented by subclasses to define the specific operation to perform (e.g., optimization, property calculation).</p> <p>Parameters:</p> Name Type Description Default <code>structure</code> <code>SiteCollection</code> <p>Pymatgen SiteCollection (Molecule or Structure) with 3D coordinates.</p> required <p>Returns:</p> Type Description <code>tuple[SiteCollection | list[SiteCollection], Optional[dict[str, Any]]]</code> <p>Tuple containing: - Processed structure(s) (single SiteCollection or list) - Dictionary of computed properties (or None)</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>This method must be implemented by subclasses.</p> Source code in <code>jfchemistry/jfchemistry.py</code> <pre><code>def operation(\n    self, structure: SiteCollection\n) -&gt; tuple[SiteCollection | list[SiteCollection], Optional[dict[str, Any]]]:\n    \"\"\"Perform the computational operation on a structure.\n\n    This method must be implemented by subclasses to define the specific\n    operation to perform (e.g., optimization, property calculation).\n\n    Args:\n        structure: Pymatgen SiteCollection (Molecule or Structure) with 3D coordinates.\n\n    Returns:\n        Tuple containing:\n            - Processed structure(s) (single SiteCollection or list)\n            - Dictionary of computed properties (or None)\n\n    Raises:\n        NotImplementedError: This method must be implemented by subclasses.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"calculators/","title":"Calculators","text":"<p>Calculators provide interfaces to various computational chemistry methods. They set up the computational method for a structure and extract properties from the calculations.</p> <p>options: show_root_heading: true show_source: true show_root_toc_entry: true members: true show_bases: true show_inheritance_diagram: true</p>"},{"location":"calculators/#jfchemistry.calculators","title":"calculators","text":"<p>Calculators for computing molecular properties.</p> <p>This module provides calculator interfaces for various computational chemistry methods. Calculators set up the computational method for a structure and extract properties from the calculations.</p> Available Calculators <ul> <li>ASECalculator: Base class for ASE-compatible calculators</li> <li>AimNet2Calculator: Neural network potential for fast energy/charge calculations</li> <li>ORBModelCalculator: Orbital Materials machine learning force field</li> <li>TBLiteCalculator: Tight-binding extended H\u00fcckel theory (xTB methods)</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from jfchemistry.calculators import TBLiteCalculator\n&gt;&gt;&gt; from pymatgen.core import Molecule\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Setup calculator\n&gt;&gt;&gt; calc = TBLiteCalculator(method=\"GFN2-xTB\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Set calculator on ASE atoms\n&gt;&gt;&gt; atoms = molecule.to_ase_atoms()\n&gt;&gt;&gt; atoms = calc.set_calculator(atoms, charge=0, spin_multiplicity=1)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Get properties\n&gt;&gt;&gt; properties = calc.get_properties(atoms)\n&gt;&gt;&gt; energy = properties[\"Global\"][\"Total Energy [eV]\"]\n</code></pre>"},{"location":"calculators/#jfchemistry.calculators-classes","title":"Classes","text":""},{"location":"calculators/#jfchemistry.calculators.ASECalculator","title":"ASECalculator  <code>dataclass</code>","text":"<pre><code>ASECalculator(charge: Optional[int] = None, spin_multiplicity: Optional[int] = None)\n</code></pre> <p>               Bases: <code>Calculator</code></p> <p>Base class for ASE calculator integration.</p> <p>This class provides the interface for setting up ASE calculators on molecular structures. Subclasses implement specific calculators like AimNet2, ORB models, or TBLite.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Descriptive name for the calculator.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Subclass implementation\n&gt;&gt;&gt; from ase import Atoms\n&gt;&gt;&gt;\n&gt;&gt;&gt; class MyCalculator(ASECalculator):\n...     def set_calculator(self, atoms, charge, spin_multiplicity):\n...         from some_package import Calculator\n...         atoms.calc = Calculator(charge=charge)\n...         return atoms\n&gt;&gt;&gt;\n&gt;&gt;&gt; calc = MyCalculator()\n&gt;&gt;&gt; atoms = Atoms('H2O', positions=[[0, 0, 0], [1, 0, 0], [0, 1, 0]])\n&gt;&gt;&gt; atoms = calc.set_calculator(atoms, charge=0, spin_multiplicity=1)\n</code></pre>"},{"location":"calculators/#jfchemistry.calculators.ASECalculator-functions","title":"Functions","text":""},{"location":"calculators/#jfchemistry.calculators.ASECalculator.set_calculator","title":"set_calculator","text":"<pre><code>set_calculator(atoms: Atoms, charge: int, spin_multiplicity: int) -&gt; Atoms\n</code></pre> <p>Set the calculator for the atoms.</p> <p>This method must be implemented by subclasses to attach a specific ASE calculator to the atoms object.</p> <p>Parameters:</p> Name Type Description Default <code>atoms</code> <code>Atoms</code> <p>ASE Atoms object representing the molecular structure.</p> required <code>charge</code> <code>int</code> <p>Total molecular charge.</p> required <code>spin_multiplicity</code> <code>int</code> <p>Spin multiplicity (2S+1 where S is total spin).</p> required <p>Returns:</p> Type Description <code>Atoms</code> <p>ASE Atoms object with the calculator attached.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>This method must be implemented by subclasses.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # In a subclass\n&gt;&gt;&gt; def set_calculator(self, atoms, charge, spin_multiplicity):\n...     from ase.calculators.emt import EMT\n...     atoms.calc = EMT()\n...     return atoms\n</code></pre> Source code in <code>jfchemistry/calculators/ase_calculator.py</code> <pre><code>def set_calculator(self, atoms: Atoms, charge: int, spin_multiplicity: int) -&gt; Atoms:\n    \"\"\"Set the calculator for the atoms.\n\n    This method must be implemented by subclasses to attach a specific\n    ASE calculator to the atoms object.\n\n    Args:\n        atoms: ASE Atoms object representing the molecular structure.\n        charge: Total molecular charge.\n        spin_multiplicity: Spin multiplicity (2S+1 where S is total spin).\n\n    Returns:\n        ASE Atoms object with the calculator attached.\n\n    Raises:\n        NotImplementedError: This method must be implemented by subclasses.\n\n    Examples:\n        &gt;&gt;&gt; # In a subclass\n        &gt;&gt;&gt; def set_calculator(self, atoms, charge, spin_multiplicity):\n        ...     from ase.calculators.emt import EMT\n        ...     atoms.calc = EMT()\n        ...     return atoms\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"calculators/#jfchemistry.calculators.AimNet2Calculator","title":"AimNet2Calculator  <code>dataclass</code>","text":"<pre><code>AimNet2Calculator(charge: Optional[int] = None, spin_multiplicity: Optional[int] = None, name: str = 'AimNet2 Calculator', model: str = 'aimnet2')\n</code></pre> <p>               Bases: <code>ASECalculator</code></p> <p>AimNet2 neural network potential calculator.</p> <p>AimNet2 is a neural network-based calculator for computing molecular energies and atomic partial charges. It provides fast predictions for molecules containing H, B, C, N, O, F, Si, P, S, Cl, As, Se, Br, and I atoms.</p> <p>The calculator requires the 'aimnet' package from: https://github.com/cfarm6/aimnetcentral.git</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the calculator (default: \"AimNet2 Calculator\").</p> <code>model</code> <code>str</code> <p>AimNet2 model to use (default: \"aimnet2\").</p> <code>charge</code> <code>Optional[int]</code> <p>Molecular charge override. If None, uses charge from structure.</p> <code>multiplicity</code> <code>Optional[int]</code> <p>Spin multiplicity override. If None, uses spin from structure.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from jfchemistry.calculators import AimNet2Calculator\n&gt;&gt;&gt; from pymatgen.core import Molecule\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Create calculator for neutral molecule\n&gt;&gt;&gt; calc = AimNet2Calculator(charge=0, multiplicity=1)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Setup calculator on structure\n&gt;&gt;&gt; atoms = molecule.to_ase_atoms()\n&gt;&gt;&gt; atoms = calc.set_calculator(atoms, charge=0, spin_multiplicity=1)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Compute properties\n&gt;&gt;&gt; properties = calc.get_properties(atoms)\n&gt;&gt;&gt; energy = properties[\"Global\"][\"Total Energy [eV]\"]\n&gt;&gt;&gt; charges = properties[\"Atomic\"][\"AimNet2 Partial Charges [e]\"]\n</code></pre>"},{"location":"calculators/#jfchemistry.calculators.AimNet2Calculator-functions","title":"Functions","text":""},{"location":"calculators/#jfchemistry.calculators.AimNet2Calculator.get_properties","title":"get_properties","text":"<pre><code>get_properties(atoms: Atoms) -&gt; dict[str, Any]\n</code></pre> <p>Extract computed properties from the AimNet2 calculation.</p> <p>Retrieves the total energy and atomic partial charges from the AimNet2 calculation on the atoms object.</p> <p>Parameters:</p> Name Type Description Default <code>atoms</code> <code>Atoms</code> <p>ASE Atoms object with AimNet2 calculator attached and calculation completed.</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary with structure: - \"Global\": {\"Total Energy [eV]\": float} - \"Atomic\": {\"AimNet2 Partial Charges [e]\": array}</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; calc = AimNet2Calculator()\n&gt;&gt;&gt; atoms = calc.set_calculator(atoms, charge=0, spin_multiplicity=1)\n&gt;&gt;&gt; atoms.get_potential_energy()  # Trigger calculation\n&gt;&gt;&gt; props = calc.get_properties(atoms)\n</code></pre> Source code in <code>jfchemistry/calculators/aimnet2_calculator.py</code> <pre><code>def get_properties(self, atoms: Atoms) -&gt; dict[str, Any]:\n    \"\"\"Extract computed properties from the AimNet2 calculation.\n\n    Retrieves the total energy and atomic partial charges from the AimNet2\n    calculation on the atoms object.\n\n    Args:\n        atoms: ASE Atoms object with AimNet2 calculator attached and calculation\n            completed.\n\n    Returns:\n        Dictionary with structure:\n            - \"Global\": {\"Total Energy [eV]\": float}\n            - \"Atomic\": {\"AimNet2 Partial Charges [e]\": array}\n\n    Examples:\n        &gt;&gt;&gt; calc = AimNet2Calculator() # doctest: +SKIP\n        &gt;&gt;&gt; atoms = calc.set_calculator(atoms, charge=0, spin_multiplicity=1) # doctest: +SKIP\n        &gt;&gt;&gt; atoms.get_potential_energy()  # Trigger calculation # doctest: +SKIP\n        &gt;&gt;&gt; props = calc.get_properties(atoms) # doctest: +SKIP\n    \"\"\"\n    energy = atoms.get_total_energy()  # type: ignore\n    charge = atoms.get_charges()  # type: ignore\n    properties = {\n        \"Global\": {\"Total Energy [eV]\": energy},\n        \"Atomic\": {\"AimNet2 Partial Charges [e]\": charge},\n    }\n\n    return properties\n</code></pre>"},{"location":"calculators/#jfchemistry.calculators.AimNet2Calculator.set_calculator","title":"set_calculator","text":"<pre><code>set_calculator(atoms: Atoms, charge: int = 0, spin_multiplicity: int = 1) -&gt; Atoms\n</code></pre> <p>Set the AimNet2 calculator on the atoms object.</p> <p>Attaches the AimNet2 ASE calculator to the atoms object with the specified charge and spin multiplicity. Validates that all atoms are supported by AimNet2.</p> <p>Parameters:</p> Name Type Description Default <code>atoms</code> <code>Atoms</code> <p>ASE Atoms object to attach calculator to.</p> required <code>charge</code> <code>int</code> <p>Total molecular charge (default: 0). Overridden by self.charge if set.</p> <code>0</code> <code>spin_multiplicity</code> <code>int</code> <p>Spin multiplicity 2S+1 (default: 1). Overridden by self.multiplicity if set.</p> <code>1</code> <p>Returns:</p> Type Description <code>Atoms</code> <p>ASE Atoms object with AimNet2 calculator attached.</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If the 'aimnet' package is not installed.</p> <code>ValueError</code> <p>If molecule contains atoms not supported by AimNet2.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from ase import Atoms\n&gt;&gt;&gt; calc = AimNet2Calculator()\n&gt;&gt;&gt; atoms = Atoms('H2O', positions=[[0,0,0], [1,0,0], [0,1,0]])\n&gt;&gt;&gt; atoms = calc.set_calculator(atoms, charge=0, spin_multiplicity=1)\n&gt;&gt;&gt; energy = atoms.get_potential_energy()\n</code></pre> Source code in <code>jfchemistry/calculators/aimnet2_calculator.py</code> <pre><code>def set_calculator(self, atoms: Atoms, charge: int = 0, spin_multiplicity: int = 1) -&gt; Atoms:\n    \"\"\"Set the AimNet2 calculator on the atoms object.\n\n    Attaches the AimNet2 ASE calculator to the atoms object with the specified\n    charge and spin multiplicity. Validates that all atoms are supported by AimNet2.\n\n    Args:\n        atoms: ASE Atoms object to attach calculator to.\n        charge: Total molecular charge (default: 0). Overridden by self.charge if set.\n        spin_multiplicity: Spin multiplicity 2S+1 (default: 1). Overridden by\n            self.multiplicity if set.\n\n    Returns:\n        ASE Atoms object with AimNet2 calculator attached.\n\n    Raises:\n        ImportError: If the 'aimnet' package is not installed.\n        ValueError: If molecule contains atoms not supported by AimNet2.\n\n    Examples:\n        &gt;&gt;&gt; from ase import Atoms # doctest: +SKIP\n        &gt;&gt;&gt; calc = AimNet2Calculator() # doctest: +SKIP\n        &gt;&gt;&gt; atoms = Atoms('H2O', positions=[[0,0,0], [1,0,0], [0,1,0]]) # doctest: +SKIP\n        &gt;&gt;&gt; atoms = calc.set_calculator(atoms, charge=0, spin_multiplicity=1) # doctest: +SKIP\n        &gt;&gt;&gt; energy = atoms.get_potential_energy() # doctest: +SKIP\n    \"\"\"\n    try:\n        from aimnet.calculators import AIMNet2ASE  # type: ignore\n    except ImportError as e:\n        raise ImportError(\n            \"The 'aimnet' package is required to use AimNet2Calculator but is not available. \"\n            \"Please install it from: https://github.com/cfarm6/aimnetcentral.git\"\n        ) from e\n    if self.charge is not None:\n        charge = self.charge\n    if self.spin_multiplicity is not None:\n        spin_multiplicity = self.spin_multiplicity\n    atoms.calc = AIMNet2ASE(self.model, charge, spin_multiplicity)\n\n    aimnet2_atomtypes = [1, 6, 7, 8, 9, 17, 16, 5, 14, 15, 33, 34, 35, 53]\n    atomic_nums = atoms.get_atomic_numbers()  # type: ignore\n    if not all(atom in aimnet2_atomtypes for atom in atomic_nums):\n        raise ValueError(\n            f\"Unsupport atomtype by AimNet2. Supported atom types are {aimnet2_atomtypes}\"\n        )\n\n    return atoms\n</code></pre>"},{"location":"calculators/#jfchemistry.calculators.ORBModelCalculator","title":"ORBModelCalculator  <code>dataclass</code>","text":"<pre><code>ORBModelCalculator(charge: Optional[int] = None, spin_multiplicity: Optional[int] = None, name: str = 'ORB Model Calculator', model: Literal['orb-v3-conservative-omol', 'orb-v3-direct-omol'] = 'orb-v3-conservative-omol', device: Literal['cpu', 'cuda'] = 'cpu', precision: Literal['float32-high', 'float32-highest', 'float64'] = 'float32-high', compile: bool = False)\n</code></pre> <p>               Bases: <code>ASECalculator</code></p> <p>Orbital Materials ORB machine learning force field calculator.</p> <p>ORB models are graph neural network-based force fields developed by Orbital Materials for fast and accurate molecular property predictions. The calculator supports both conservative and direct versions of the ORB-v3 model.</p> <p>The calculator requires the 'orb-models' package from: https://github.com/orbital-materials/orb-models</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the calculator (default: \"ORB Model Calculator\").</p> <code>model</code> <code>Literal['orb-v3-conservative-omol', 'orb-v3-direct-omol']</code> <p>ORB model variant to use. Options: - \"orb-v3-conservative-omol\": Conservative model (recommended) - \"orb-v3-direct-omol\": Direct model</p> <code>charge</code> <code>Optional[int]</code> <p>Molecular charge override. If None, uses charge from structure.</p> <code>multiplicity</code> <code>Optional[int]</code> <p>Spin multiplicity override. If None, uses spin from structure.</p> <code>device</code> <code>Literal['cpu', 'cuda']</code> <p>Computation device (\"cpu\" or \"cuda\"). Default: \"cpu\".</p> <code>precision</code> <code>Literal['float32-high', 'float32-highest', 'float64']</code> <p>Numerical precision for calculations. Options: - \"float32-high\": Standard precision (default) - \"float32-highest\": Higher precision float32 - \"float64\": Double precision</p> <code>compile</code> <code>bool</code> <p>Whether to compile the model for faster inference (default: False).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from jfchemistry.calculators import ORBModelCalculator\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Create calculator with GPU acceleration\n&gt;&gt;&gt; calc = ORBModelCalculator(\n...     model=\"orb-v3-conservative-omol\",\n...     device=\"cuda\",\n...     precision=\"float32-highest\"\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Setup on structure\n&gt;&gt;&gt; atoms = molecule.to_ase_atoms()\n&gt;&gt;&gt; atoms = calc.set_calculator(atoms, charge=0, spin_multiplicity=1)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Get properties\n&gt;&gt;&gt; props = calc.get_properties(atoms)\n&gt;&gt;&gt; energy = props[\"Global\"][\"Total Energy [eV]\"]\n</code></pre>"},{"location":"calculators/#jfchemistry.calculators.ORBModelCalculator-functions","title":"Functions","text":""},{"location":"calculators/#jfchemistry.calculators.ORBModelCalculator.get_properties","title":"get_properties","text":"<pre><code>get_properties(atoms: Atoms) -&gt; dict[str, Any]\n</code></pre> <p>Extract computed properties from the ORB calculation.</p> <p>Retrieves the total energy from the ORB model calculation.</p> <p>Parameters:</p> Name Type Description Default <code>atoms</code> <code>Atoms</code> <p>ASE Atoms object with ORB calculator attached and calculation completed.</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary with structure: - \"Global\": {\"Total Energy [eV]\": float}</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; calc = ORBModelCalculator()\n&gt;&gt;&gt; atoms = calc.set_calculator(atoms, charge=0, spin_multiplicity=1)\n&gt;&gt;&gt; atoms.get_potential_energy()  # Trigger calculation\n&gt;&gt;&gt; props = calc.get_properties(atoms)\n&gt;&gt;&gt; print(props[\"Global\"][\"Total Energy [eV]\"])\n-234.567\n</code></pre> Source code in <code>jfchemistry/calculators/orb_calculator.py</code> <pre><code>def get_properties(self, atoms: Atoms) -&gt; dict[str, Any]:\n    \"\"\"Extract computed properties from the ORB calculation.\n\n    Retrieves the total energy from the ORB model calculation.\n\n    Args:\n        atoms: ASE Atoms object with ORB calculator attached and calculation\n            completed.\n\n    Returns:\n        Dictionary with structure:\n            - \"Global\": {\"Total Energy [eV]\": float}\n\n    Examples:\n        &gt;&gt;&gt; calc = ORBModelCalculator() # doctest: +SKIP\n        &gt;&gt;&gt; atoms = calc.set_calculator(atoms, charge=0, spin_multiplicity=1) # doctest: +SKIP\n        &gt;&gt;&gt; atoms.get_potential_energy()  # Trigger calculation # doctest: +SKIP\n        &gt;&gt;&gt; props = calc.get_properties(atoms) # doctest: +SKIP\n        &gt;&gt;&gt; print(props[\"Global\"][\"Total Energy [eV]\"]) # doctest: +SKIP\n        -234.567\n    \"\"\"\n    energy = atoms.get_total_energy()  # type: ignore\n    properties = {\n        \"Global\": {\"Total Energy [eV]\": energy},\n    }\n\n    return properties\n</code></pre>"},{"location":"calculators/#jfchemistry.calculators.ORBModelCalculator.set_calculator","title":"set_calculator","text":"<pre><code>set_calculator(atoms: Atoms, charge: int = 0, spin_multiplicity: int = 1) -&gt; Atoms\n</code></pre> <p>Set the ORB model calculator on the atoms object.</p> <p>Loads the specified ORB model and attaches it as an ASE calculator to the atoms object. Stores charge and spin information in atoms.info dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>atoms</code> <code>Atoms</code> <p>ASE Atoms object to attach calculator to.</p> required <code>charge</code> <code>int</code> <p>Total molecular charge (default: 0). Overridden by self.charge if set.</p> <code>0</code> <code>spin_multiplicity</code> <code>int</code> <p>Spin multiplicity 2S+1 (default: 1). Overridden by self.multiplicity if set.</p> <code>1</code> <p>Returns:</p> Type Description <code>Atoms</code> <p>ASE Atoms object with ORB calculator attached and charge/spin set.</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If the 'orb-models' package is not installed.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; calc = ORBModelCalculator(device=\"cuda\", compile=True)\n&gt;&gt;&gt; atoms = molecule.to_ase_atoms()\n&gt;&gt;&gt; atoms = calc.set_calculator(atoms, charge=0, spin_multiplicity=1)\n&gt;&gt;&gt; # Charge and spin are stored in atoms.info\n&gt;&gt;&gt; print(atoms.info[\"charge\"])\n0\n</code></pre> Source code in <code>jfchemistry/calculators/orb_calculator.py</code> <pre><code>def set_calculator(self, atoms: Atoms, charge: int = 0, spin_multiplicity: int = 1) -&gt; Atoms:\n    \"\"\"Set the ORB model calculator on the atoms object.\n\n    Loads the specified ORB model and attaches it as an ASE calculator to the\n    atoms object. Stores charge and spin information in atoms.info dictionary.\n\n    Args:\n        atoms: ASE Atoms object to attach calculator to.\n        charge: Total molecular charge (default: 0). Overridden by self.charge if set.\n        spin_multiplicity: Spin multiplicity 2S+1 (default: 1). Overridden by\n            self.multiplicity if set.\n\n    Returns:\n        ASE Atoms object with ORB calculator attached and charge/spin set.\n\n    Raises:\n        ImportError: If the 'orb-models' package is not installed.\n\n    Examples:\n        &gt;&gt;&gt; calc = ORBModelCalculator(device=\"cuda\", compile=True) # doctest: +SKIP\n        &gt;&gt;&gt; atoms = molecule.to_ase_atoms() # doctest: +SKIP\n        &gt;&gt;&gt; atoms = calc.set_calculator(atoms, charge=0, spin_multiplicity=1) # doctest: +SKIP\n        &gt;&gt;&gt; # Charge and spin are stored in atoms.info\n        &gt;&gt;&gt; print(atoms.info[\"charge\"]) # doctest: +SKIP\n        0\n    \"\"\"\n    try:\n        from orb_models.forcefield import pretrained  # type: ignore\n        from orb_models.forcefield.calculator import ORBCalculator  # type: ignore\n    except ImportError as e:\n        raise ImportError(\n            \"The 'orb-models' package is required to use ORBCalculator but is not available.\"\n            \"Please install it from: https://github.com/orbital-materials/orb-models\"\n        ) from e\n    if self.charge is not None:\n        charge = self.charge\n    if self.spin_multiplicity is not None:\n        spin_multiplicity = self.spin_multiplicity\n\n    orbff = getattr(pretrained, self.model.replace(\"-\", \"_\"))(\n        device=self.device,\n        precision=self.precision,\n        compile=self.compile,\n    )\n\n    atoms.calc = ORBCalculator(orbff, device=self.device)\n    atoms.info[\"charge\"] = charge\n    atoms.info[\"spin\"] = spin_multiplicity\n    return atoms\n</code></pre>"},{"location":"calculators/#jfchemistry.calculators.TBLiteCalculator","title":"TBLiteCalculator  <code>dataclass</code>","text":"<pre><code>TBLiteCalculator(charge: Optional[int] = None, spin_multiplicity: Optional[int] = None, name: str = 'TBLite Calculator', method: Literal['GFN1-xTB', 'GFN2-xTB', 'IPEA1-xTB'] = 'GFN2-xTB', accuracy: float = 1.0, electronic_temperature: float = 300.0, max_iterations: int = 250, initial_guess: Literal['sad', 'eeq'] = 'sad', mixer_damping: float = 0.4, verbosity: int = 0)\n</code></pre> <p>               Bases: <code>ASECalculator</code></p> <p>TBLite calculator for GFN-xTB semi-empirical methods.</p> <p>TBLite provides implementations of the GFN (Geometrical-dependent Forcefield for Noncovalent interactions) extended tight-binding methods developed by the Grimme group. These methods offer a good balance between accuracy and computational efficiency for large molecular systems.</p> <p>The calculator computes extensive molecular properties including energies, partial charges, bond orders, molecular orbitals, dipole/quadrupole moments, and HOMO-LUMO gaps.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the calculator (default: \"TBLite Calculator\").</p> <code>method</code> <code>Literal['GFN1-xTB', 'GFN2-xTB', 'IPEA1-xTB']</code> <p>Semi-empirical method to use. Options: - \"GFN2-xTB\": GFN2-xTB method (default, recommended for most cases) - \"GFN1-xTB\": GFN1-xTB method - \"IPEA1-xTB\": IPEA1-xTB method</p> <code>charge</code> <code>Optional[int]</code> <p>Molecular charge override. If None, uses charge from structure.</p> <code>multiplicity</code> <code>Optional[int]</code> <p>Spin multiplicity override. If None, uses spin from structure.</p> <code>accuracy</code> <code>float</code> <p>Numerical accuracy parameter (default: 1.0).</p> <code>electronic_temperature</code> <code>float</code> <p>Electronic temperature in Kelvin for Fermi smearing (default: 300.0).</p> <code>max_iterations</code> <code>int</code> <p>Maximum SCF iterations (default: 250).</p> <code>initial_guess</code> <code>Literal['sad', 'eeq']</code> <p>Initial guess for electronic structure. Options: - \"sad\": Superposition of atomic densities (default) - \"eeq\": Electronegativity equilibration</p> <code>mixer_damping</code> <code>float</code> <p>Damping parameter for SCF mixing (default: 0.4).</p> <code>verbosity</code> <code>int</code> <p>Output verbosity level (default: 0).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from jfchemistry.calculators import TBLiteCalculator\n&gt;&gt;&gt; from ase.build import molecule\n&gt;&gt;&gt; from pymatgen.core import Molecule\n&gt;&gt;&gt; mol = Molecule.from_ase_atoms(molecule(\"C2H6\"))\n&gt;&gt;&gt; # Create calculator with custom settings\n&gt;&gt;&gt; calc = TBLiteCalculator(\n...     method=\"GFN2-xTB\",\n...     accuracy=0.1,  # Tighter convergence\n...     max_iterations=500\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Compute properties\n&gt;&gt;&gt; atoms = mol.to_ase_atoms()\n&gt;&gt;&gt; atoms = calc.set_calculator(atoms, charge=0, spin_multiplicity=1)\n&gt;&gt;&gt; props = calc.get_properties(atoms)\n</code></pre>"},{"location":"calculators/#jfchemistry.calculators.TBLiteCalculator-functions","title":"Functions","text":""},{"location":"calculators/#jfchemistry.calculators.TBLiteCalculator.get_properties","title":"get_properties","text":"<pre><code>get_properties(atoms: Atoms) -&gt; dict[str, Any]\n</code></pre> <p>Extract comprehensive properties from the TBLite calculation.</p> <p>Computes and organizes a wide range of molecular properties from the GFN-xTB calculation including energies, multipole moments, partial charges, bond orders, and molecular orbital information.</p> <p>Parameters:</p> Name Type Description Default <code>atoms</code> <code>Atoms</code> <p>ASE Atoms object with TBLite calculator attached and calculation completed.</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary with four main sections: - \"Global\": System-level properties     - \"Total Energy [eV]\": Total molecular energy     - \"Dipole Moment [D]\": Dipole moment vector (x, y, z)     - \"Quadrupole Moment [D]\": Quadrupole tensor (xx, yy, zz, xy, xz, yz)     - \"Density Matrix\": Electronic density matrix     - \"HOMO-LUMO Gap [eV]\": Energy gap between frontier orbitals     - \"HOMO Energy [eV]\": Highest occupied molecular orbital energy     - \"LUMO Energy [eV]\": Lowest unoccupied molecular orbital energy - \"Atomic\": Per-atom properties     - \"Mulliken Partial Charges [e]\": Mulliken population analysis charges - \"Bond\": Pairwise bond properties     - \"Wiberg Bond Order\": List of bond orders for all atom pairs         Each entry: {\"i\": atom_index, \"j\": atom_index, \"value\": bond_order} - \"Orbital\": Molecular orbital information     - \"Orbital Energies [eV]\": Energy of each molecular orbital     - \"Orbital Occupations\": Occupation number of each orbital     - \"Orbital Coefficients\": Coefficients of molecular orbitals</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from ase.build import molecule\n&gt;&gt;&gt; from pymatgen.core import Molecule\n&gt;&gt;&gt; from jfchemistry.calculators import TBLiteCalculator\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Create a simple molecule (ethane) and set up calculator\n&gt;&gt;&gt; mol = Molecule.from_ase_atoms(molecule(\"C2H6\"))\n&gt;&gt;&gt; calc = TBLiteCalculator(method=\"GFN2-xTB\")\n&gt;&gt;&gt; atoms = mol.to_ase_atoms()\n&gt;&gt;&gt; atoms = calc.set_calculator(atoms, charge=0, spin_multiplicity=1)\n&gt;&gt;&gt; props = calc.get_properties(atoms)\n</code></pre> Source code in <code>jfchemistry/calculators/tblite_calculator.py</code> <pre><code>def get_properties(self, atoms: Atoms) -&gt; dict[str, Any]:\n    \"\"\"Extract comprehensive properties from the TBLite calculation.\n\n    Computes and organizes a wide range of molecular properties from the\n    GFN-xTB calculation including energies, multipole moments, partial charges,\n    bond orders, and molecular orbital information.\n\n    Args:\n        atoms: ASE Atoms object with TBLite calculator attached and calculation\n            completed.\n\n    Returns:\n        Dictionary with four main sections:\n            - \"Global\": System-level properties\n                - \"Total Energy [eV]\": Total molecular energy\n                - \"Dipole Moment [D]\": Dipole moment vector (x, y, z)\n                - \"Quadrupole Moment [D]\": Quadrupole tensor (xx, yy, zz, xy, xz, yz)\n                - \"Density Matrix\": Electronic density matrix\n                - \"HOMO-LUMO Gap [eV]\": Energy gap between frontier orbitals\n                - \"HOMO Energy [eV]\": Highest occupied molecular orbital energy\n                - \"LUMO Energy [eV]\": Lowest unoccupied molecular orbital energy\n            - \"Atomic\": Per-atom properties\n                - \"Mulliken Partial Charges [e]\": Mulliken population analysis charges\n            - \"Bond\": Pairwise bond properties\n                - \"Wiberg Bond Order\": List of bond orders for all atom pairs\n                    Each entry: {\"i\": atom_index, \"j\": atom_index, \"value\": bond_order}\n            - \"Orbital\": Molecular orbital information\n                - \"Orbital Energies [eV]\": Energy of each molecular orbital\n                - \"Orbital Occupations\": Occupation number of each orbital\n                - \"Orbital Coefficients\": Coefficients of molecular orbitals\n\n    Examples:\n        &gt;&gt;&gt; from ase.build import molecule # doctest: +SKIP\n        &gt;&gt;&gt; from pymatgen.core import Molecule # doctest: +SKIP\n        &gt;&gt;&gt; from jfchemistry.calculators import TBLiteCalculator # doctest: +SKIP\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Create a simple molecule (ethane) and set up calculator\n        &gt;&gt;&gt; mol = Molecule.from_ase_atoms(molecule(\"C2H6\")) # doctest: +SKIP\n        &gt;&gt;&gt; calc = TBLiteCalculator(method=\"GFN2-xTB\") # doctest: +SKIP\n        &gt;&gt;&gt; atoms = mol.to_ase_atoms() # doctest: +SKIP\n        &gt;&gt;&gt; atoms = calc.set_calculator(atoms, charge=0, spin_multiplicity=1) # doctest: +SKIP\n        &gt;&gt;&gt; props = calc.get_properties(atoms) # doctest: +SKIP\n    \"\"\"\n    atoms.get_potential_energy()\n    props = atoms.calc._res.dict()\n    energy = props[\"energy\"] * Hartree\n    dipole = props[\"dipole\"] * Bohr\n    quadrupole = props[\"quadrupole\"] * Bohr**2\n    charges = props[\"charges\"]\n    bond_orders = props[\"bond-orders\"]\n    orbital_energies = props[\"orbital-energies\"] * Hartree\n    orbital_occupations = props[\"orbital-occupations\"]\n    # Report HOMO-LUMO Gap\n    homo_index = orbital_occupations.nonzero()[0][-1]\n    lumo_index = homo_index + 1\n    homo_energy = orbital_energies[homo_index]\n    lumo_energy = orbital_energies[lumo_index]\n    homo_lumo_gap = lumo_energy - homo_energy\n    orbital_coefficients = props[\"orbital-coefficients\"]\n    density_matrix = props[\"density-matrix\"]\n    wbo = []\n    for i in range(len(bond_orders)):\n        for j in range(len(bond_orders[i])):\n            wbo.append(\n                {\n                    \"i\": i,\n                    \"j\": j,\n                    \"value\": bond_orders[i][j],\n                }\n            )\n    properties = {\n        \"Global\": {\n            \"Total Energy [eV]\": energy,\n            \"Dipole Moment [D]\": dipole,\n            \"Quadrupole Moment [D]\": {\n                \"xx\": quadrupole[0],\n                \"yy\": quadrupole[1],\n                \"zz\": quadrupole[2],\n                \"xy\": quadrupole[3],\n                \"xz\": quadrupole[4],\n                \"yz\": quadrupole[5],\n            },\n            \"Density Matrix\": density_matrix,\n            \"HOMO-LUMO Gap [eV]\": homo_lumo_gap,\n            \"HOMO Energy [eV]\": homo_energy,\n            \"LUMO Energy [eV]\": lumo_energy,\n        },\n        \"Atomic\": {\n            \"Mulliken Partial Charges [e]\": charges,\n        },\n        \"Bond\": {\"Wiberg Bond Order\": wbo},\n        \"Orbital\": {\n            \"Orbital Energies [eV]\": orbital_energies,\n            \"Orbital Occupations\": orbital_occupations,\n            \"Orbital Coefficients\": orbital_coefficients,\n        },\n    }\n\n    return properties\n</code></pre>"},{"location":"calculators/#jfchemistry.calculators.TBLiteCalculator.set_calculator","title":"set_calculator","text":"<pre><code>set_calculator(atoms: Atoms, charge: int = 0, spin_multiplicity: int = 1) -&gt; Atoms\n</code></pre> <p>Set the TBLite calculator on the atoms object.</p> <p>Configures and attaches a TBLite GFN-xTB calculator to the atoms object with the specified method, charge, and SCF parameters.</p> <p>Parameters:</p> Name Type Description Default <code>atoms</code> <code>Atoms</code> <p>ASE Atoms object to attach calculator to.</p> required <code>charge</code> <code>int</code> <p>Total molecular charge (default: 0). Overridden by self.charge if set.</p> <code>0</code> <code>spin_multiplicity</code> <code>int</code> <p>Spin multiplicity 2S+1 (default: 1). Overridden by self.multiplicity if set.</p> <code>1</code> <p>Returns:</p> Type Description <code>Atoms</code> <p>ASE Atoms object with TBLite calculator attached.</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If the 'tblite' package is not installed.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from ase.build import molecule\n&gt;&gt;&gt; from jfchemistry.calculators import TBLiteCalculator\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Create calculator and set up a water molecule\n&gt;&gt;&gt; calc = TBLiteCalculator(method=\"GFN2-xTB\")\n&gt;&gt;&gt; atoms = molecule(\"H2O\")\n&gt;&gt;&gt; atoms = calc.set_calculator(atoms, charge=0, spin_multiplicity=1)\n&gt;&gt;&gt;\n&gt;&gt;&gt; props = atoms.get_properties()\n&gt;&gt;&gt; energy = props[\"Global\"][\"Total Energy [eV]\"]\n</code></pre> Source code in <code>jfchemistry/calculators/tblite_calculator.py</code> <pre><code>def set_calculator(self, atoms: Atoms, charge: int = 0, spin_multiplicity: int = 1) -&gt; Atoms:\n    \"\"\"Set the TBLite calculator on the atoms object.\n\n    Configures and attaches a TBLite GFN-xTB calculator to the atoms object\n    with the specified method, charge, and SCF parameters.\n\n    Args:\n        atoms: ASE Atoms object to attach calculator to.\n        charge: Total molecular charge (default: 0). Overridden by self.charge if set.\n        spin_multiplicity: Spin multiplicity 2S+1 (default: 1). Overridden by\n            self.multiplicity if set.\n\n    Returns:\n        ASE Atoms object with TBLite calculator attached.\n\n    Raises:\n        ImportError: If the 'tblite' package is not installed.\n\n    Examples:\n        &gt;&gt;&gt; from ase.build import molecule # doctest: +SKIP\n        &gt;&gt;&gt; from jfchemistry.calculators import TBLiteCalculator # doctest: +SKIP\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Create calculator and set up a water molecule\n        &gt;&gt;&gt; calc = TBLiteCalculator(method=\"GFN2-xTB\") # doctest: +SKIP\n        &gt;&gt;&gt; atoms = molecule(\"H2O\") # doctest: +SKIP\n        &gt;&gt;&gt; atoms = calc.set_calculator(atoms, charge=0, spin_multiplicity=1) # doctest: +SKIP\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; props = atoms.get_properties() # doctest: +SKIP\n        &gt;&gt;&gt; energy = props[\"Global\"][\"Total Energy [eV]\"] # doctest: +SKIP\n    \"\"\"\n    try:\n        from tblite.ase import TBLite\n    except ImportError as e:\n        raise ImportError(\n            \"The 'tblite' package is required to use TBLiteCalculator but is not available. \"\n            \"Please install it with: pip install tblite or conda install tblite-python\"\n        ) from e\n    if self.charge is not None:\n        charge = self.charge\n    if self.spin_multiplicity is not None:\n        spin_multiplicity = self.spin_multiplicity\n    atoms.calc = TBLite(\n        method=self.method,\n        charge=charge,\n        spin_multiplicity=spin_multiplicity,\n        accuracy=self.accuracy,\n        electronic_temperature=self.electronic_temperature,\n        max_iterations=self.max_iterations,\n        initial_guess=self.initial_guess,\n        mixer_damping=self.mixer_damping,\n        verbosity=self.verbosity,\n    )\n\n    return atoms\n</code></pre>"},{"location":"conformers/","title":"Conformer Generation","text":"<p>Conformer generation methods explore the conformational space of molecules to identify energetically favorable conformations. This is crucial for understanding molecular flexibility and finding global minimum structures.</p> <p>options: show_root_heading: true show_source: true show_root_toc_entry: true members: true show_bases: true show_inheritance_diagram: true</p>"},{"location":"conformers/#jfchemistry.conformers","title":"conformers","text":"<p>Conformer generation methods.</p> <p>This module provides tools for generating multiple conformations of molecular structures to explore conformational space and identify low-energy structures.</p> Available Methods <ul> <li>ConformerGeneration: Base class for conformer generation</li> <li>CRESTConformers: CREST-based conformer search using metadynamics</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from jfchemistry.conformers import CRESTConformers\n&gt;&gt;&gt; from pymatgen.core import Molecule\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Generate conformers using CREST\n&gt;&gt;&gt; conformer_gen = CRESTConformers(\n...     runtype=\"imtd-gc\",\n...     ewin=6.0,  # Energy window in kcal/mol\n...     calculation_energy_method=\"gfnff\",\n...     calculation_dynamics_method=\"gfnff\"\n... )\n&gt;&gt;&gt; # Generate conformers\n&gt;&gt;&gt; job = conformer_gen.make(molecule)\n&gt;&gt;&gt; conformers = job.output[\"structure\"]\n</code></pre>"},{"location":"conformers/#jfchemistry.conformers-classes","title":"Classes","text":""},{"location":"conformers/#jfchemistry.conformers.CRESTConformers","title":"CRESTConformers  <code>dataclass</code>","text":"<pre><code>CRESTConformers(name: str = 'CREST Conformer Generation', runtype: Literal['imtd-gc', 'nci-mtd', 'imtd-smtd'] = 'imtd-gc', preopt: bool = True, multilevelopt: bool = True, topo: bool = True, parallel: int = 1, opt_engine: Literal['ancopt', 'rfo', 'gd'] = 'ancopt', hess_update: Literal['bfgs', 'powell', 'sd1', 'bofill', 'schlegel'] = 'bfgs', maxcycle: Optional[int] = None, optlev: Literal['crude', 'vloose', 'loose', 'normal', 'tight', 'vtight', 'extreme'] = 'normal', converge_e: Optional[float] = None, converge_g: Optional[float] = None, freeze: Optional[str] = None, ewin: float = 6.0, ethr: float = 0.05, rthr: float = 0.125, bthr: float = 0.01, calculation_energy_method: Literal['gfn2', 'gfn1', 'gfn0', 'gfnff'] = 'gfn2', calculation_energy_calcspace: Optional[str] = None, calculation_energy_chrg: Optional[int] = None, calculation_energy_uhf: Optional[int] = None, calculation_energy_rdwbo: bool = False, calculation_energy_rddip: bool = False, calculation_energy_dipgrad: bool = False, calculation_energy_gradfile: Optional[str] = None, calculation_energy_gradtype: Optional[Literal['engrad']] = None, calculation_dynamics_method: Literal['gfn2', 'gfn1', 'gfn0', 'gfnff'] = 'gfn2', calculation_dynamics_calcspace: Optional[str] = None, calculation_dynamics_chrg: Optional[int] = None, calculation_dynamics_uhf: Optional[int] = None, calculation_dynamics_rdwbo: bool = False, calculation_dynamics_rddip: bool = False, calculation_dynamics_dipgrad: bool = False, calculation_dynamics_gradfile: Optional[str] = None, calculation_dynamics_gradtype: Optional[Literal['engrad']] = None, dynamics_dump: float = 100.0)\n</code></pre> <p>               Bases: <code>ConformerGeneration</code></p> <p>CREST conformer generation using metadynamics sampling.</p> <p>CREST (Conformer-Rotamer Ensemble Sampling Tool) performs automated conformational and rotameric searches using metadynamics simulations with GFN-xTB tight-binding methods. It efficiently explores conformational space to identify unique low-energy conformers.</p> <p>The implementation supports various metadynamics protocols and provides extensive control over optimization settings, energy calculations, and conformer filtering.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the job (default: \"CREST Conformer Generation\").</p> <code>runtype</code> <code>Literal['imtd-gc', 'nci-mtd', 'imtd-smtd']</code> <p>Metadynamics protocol to use: - \"imtd-gc\": Iterative metadynamics with genetic crossing (default) - \"nci-mtd\": Non-covalent interaction metadynamics - \"imtd-smtd\": Iterative metadynamics with static metadynamics</p> <code>preopt</code> <code>bool</code> <p>Pre-optimize structure before conformer search (default: True).</p> <code>multilevelopt</code> <code>bool</code> <p>Use multi-level optimization (default: True).</p> <code>topo</code> <code>bool</code> <p>Enable topology-based filtering (default: True).</p> <code>parallel</code> <code>int</code> <p>Number of parallel threads (default: 1).</p> <code>opt_engine</code> <code>Literal['ancopt', 'rfo', 'gd']</code> <p>Optimization algorithm: - \"ancopt\": Approximate normal coordinate optimizer (default) - \"rfo\": Rational function optimizer - \"gd\": Gradient descent</p> <code>hess_update</code> <code>Literal['bfgs', 'powell', 'sd1', 'bofill', 'schlegel']</code> <p>Hessian update method: - \"bfgs\": BFGS update (default) - \"powell\": Powell update - \"sd1\": Steepest descent - \"bofill\": Bofill update - \"schlegel\": Schlegel update</p> <code>maxcycle</code> <code>Optional[int]</code> <p>Maximum optimization cycles (default: None, auto).</p> <code>optlev</code> <code>Literal['crude', 'vloose', 'loose', 'normal', 'tight', 'vtight', 'extreme']</code> <p>Optimization convergence level: - \"crude\", \"vloose\", \"loose\", \"normal\" (default), \"tight\", \"vtight\", \"extreme\"</p> <code>converge_e</code> <code>Optional[float]</code> <p>Energy convergence threshold (default: None, auto).</p> <code>converge_g</code> <code>Optional[float]</code> <p>Gradient convergence threshold (default: None, auto).</p> <code>freeze</code> <code>Optional[str]</code> <p>Freeze constraints string (default: None).</p> <code>ewin</code> <code>float</code> <p>Energy window for conformer selection in kcal/mol (default: 6.0).</p> <code>ethr</code> <code>float</code> <p>Energy threshold for duplicate detection in kcal/mol (default: 0.05).</p> <code>rthr</code> <code>float</code> <p>RMSD threshold for structural similarity in Angstrom (default: 0.125).</p> <code>bthr</code> <code>float</code> <p>Rotational constant threshold for duplicate detection (default: 0.01).</p> <code>calculation_energy_method</code> <code>Literal['gfn2', 'gfn1', 'gfn0', 'gfnff']</code> <p>Method for energy calculations: - \"gfn2\" (default), \"gfn1\", \"gfn0\", \"gfnff\"</p> <code>calculation_energy_calcspace</code> <code>Optional[str]</code> <p>Calculation space setting (default: None).</p> <code>calculation_energy_chrg</code> <code>Optional[int]</code> <p>Charge for energy calculations (default: None, from structure).</p> <code>calculation_energy_uhf</code> <code>Optional[int]</code> <p>Unpaired electrons for energy calc (default: None).</p> <code>calculation_energy_rdwbo</code> <code>bool</code> <p>Read Wiberg bond orders (default: False).</p> <code>calculation_energy_rddip</code> <code>bool</code> <p>Read dipole moments (default: False).</p> <code>calculation_energy_dipgrad</code> <code>bool</code> <p>Compute dipole gradients (default: False).</p> <code>calculation_energy_gradfile</code> <code>Optional[str]</code> <p>External gradient file (default: None).</p> <code>calculation_energy_gradtype</code> <code>Optional[Literal['engrad']]</code> <p>Gradient file type (default: None).</p> <code>calculation_dynamics_method</code> <code>Literal['gfn2', 'gfn1', 'gfn0', 'gfnff']</code> <p>Method for metadynamics: - \"gfn2\" (default), \"gfn1\", \"gfn0\", \"gfnff\"</p> <code>calculation_dynamics_calcspace</code> <code>Optional[str]</code> <p>Calculation space for dynamics (default: None).</p> <code>calculation_dynamics_chrg</code> <code>Optional[int]</code> <p>Charge for dynamics (default: None, from structure).</p> <code>calculation_dynamics_uhf</code> <code>Optional[int]</code> <p>Unpaired electrons for dynamics (default: None).</p> <code>calculation_dynamics_rdwbo</code> <code>bool</code> <p>Read Wiberg bond orders in dynamics (default: False).</p> <code>calculation_dynamics_rddip</code> <code>bool</code> <p>Read dipole in dynamics (default: False).</p> <code>calculation_dynamics_dipgrad</code> <code>bool</code> <p>Compute dipole gradients in dynamics (default: False).</p> <code>calculation_dynamics_gradfile</code> <code>Optional[str]</code> <p>External gradient file for dynamics (default: None).</p> <code>calculation_dynamics_gradtype</code> <code>Optional[Literal['engrad']]</code> <p>Gradient file type for dynamics (default: None).</p> <code>dynamics_dump</code> <code>float</code> <p>Dynamics trajectory dump frequency (default: 100.0).</p> References <ul> <li>CREST Documentation: https://crest-lab.github.io/crest-docs/</li> <li>Pracht et al., PCCP 2020, 22, 7169-7192</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pymatgen.core import Molecule\n&gt;&gt;&gt; from ase.build import molecule\n&gt;&gt;&gt; from jfchemistry.conformers import CRESTConformers\n&gt;&gt;&gt;\n&gt;&gt;&gt; mol = Molecule.from_ase_atoms(molecule(\"C2H6\"))\n&gt;&gt;&gt; mol = mol.set_charge_and_spin(0, 1)\n&gt;&gt;&gt; # Basic conformer search\n&gt;&gt;&gt; conf_gen = CRESTConformers(\n...     ewin=6.0,\n...     calculation_energy_method=\"gfnff\",\n...     calculation_dynamics_method=\"gfnff\"\n... )\n&gt;&gt;&gt; structures, properties = conf_gen.operation(mol)\n&gt;&gt;&gt; type(structures[0])\n&lt;class 'pymatgen.core.structure.Molecule'&gt;\n</code></pre>"},{"location":"conformers/#jfchemistry.conformers.CRESTConformers-functions","title":"Functions","text":""},{"location":"conformers/#jfchemistry.conformers.CRESTConformers.operation","title":"operation","text":"<pre><code>operation(structure: SiteCollection) -&gt; tuple[SiteCollection | list[SiteCollection], Optional[dict[str, Any]]]\n</code></pre> <p>Generate conformers using CREST metadynamics search.</p> <p>Performs a conformational search using CREST with the configured metadynamics protocol and GFN-xTB method. The calculation runs in a temporary directory and returns the unique low-energy conformers.</p> <p>Parameters:</p> Name Type Description Default <code>structure</code> <code>SiteCollection</code> <p>Input molecular structure with 3D coordinates. The structure's charge property is used if calculation charges are not explicitly set.</p> required <p>Returns:</p> Type Description <code>tuple[SiteCollection | list[SiteCollection], Optional[dict[str, Any]]]</code> <p>Tuple containing: - List of conformer structures sorted by energy - None (no additional properties returned)</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from jfchemistry.conformers import CRESTConformers\n&gt;&gt;&gt; from pymatgen.core import Molecule\n&gt;&gt;&gt; from ase.build import molecule\n&gt;&gt;&gt; mol = Molecule.from_ase_atoms(molecule(\"C2H6\"))\n&gt;&gt;&gt; mol = mol.set_charge_and_spin(0, 1)\n&gt;&gt;&gt; gen = CRESTConformers(ewin=6.0, parallel=4)\n&gt;&gt;&gt; conformers, props = gen.operation(mol)\n&gt;&gt;&gt; len(conformers)\n1\n</code></pre> Source code in <code>jfchemistry/conformers/crest.py</code> <pre><code>def operation(\n    self, structure: SiteCollection\n) -&gt; tuple[SiteCollection | list[SiteCollection], Optional[dict[str, Any]]]:\n    \"\"\"Generate conformers using CREST metadynamics search.\n\n    Performs a conformational search using CREST with the configured\n    metadynamics protocol and GFN-xTB method. The calculation runs in\n    a temporary directory and returns the unique low-energy conformers.\n\n    Args:\n        structure: Input molecular structure with 3D coordinates. The\n            structure's charge property is used if calculation charges\n            are not explicitly set.\n\n    Returns:\n        Tuple containing:\n            - List of conformer structures sorted by energy\n            - None (no additional properties returned)\n\n    Examples:\n        &gt;&gt;&gt; from jfchemistry.conformers import CRESTConformers\n        &gt;&gt;&gt; from pymatgen.core import Molecule\n        &gt;&gt;&gt; from ase.build import molecule\n        &gt;&gt;&gt; mol = Molecule.from_ase_atoms(molecule(\"C2H6\"))\n        &gt;&gt;&gt; mol = mol.set_charge_and_spin(0, 1)\n        &gt;&gt;&gt; gen = CRESTConformers(ewin=6.0, parallel=4)\n        &gt;&gt;&gt; conformers, props = gen.operation(mol)\n        &gt;&gt;&gt; len(conformers)\n        1\n    \"\"\"\n    # Write structures to sdf file\n    structure.to(\"input.sdf\", fmt=\"sdf\")\n\n    if self.calculation_energy_chrg is None:\n        self.calculation_energy_chrg = structure.charge\n    if self.calculation_dynamics_chrg is None:\n        self.calculation_dynamics_chrg = structure.charge\n    self.input = \"input.sdf\"\n    # Empty strucutres\n    d = {\"calculation\": {}, \"cregen\": {}, \"dynamics\": {\"active\": [2]}}\n    calculation_blocks = {\"energy\": {}, \"dynamics\": {}}\n    # Fill in dictionaries for toml\n    for k, v in vars(self).items():\n        if v is None:\n            continue\n        if k == \"name\":\n            continue\n        if k.split(\"_\")[0] == \"calculation\":\n            if k.split(\"_\")[1] == \"energy\" or k.split(\"_\")[1] == \"dynamics\":\n                calculation_blocks[k.split(\"_\")[1]][k.split(\"_\")[2]] = v\n        elif k.split(\"_\")[0] == \"dynamics\":\n            d[\"dynamics\"][k.split(\"_\")[1]] = v\n        elif k in [\"ewin\", \"ethr\", \"rthr\", \"bthr\"]:\n            d[\"cregen\"][k] = v\n        elif k in [\n            \"type\",\n            \"elog\",\n            \"eprint\",\n            \"opt_engine\",\n            \"hess_update\",\n            \"maxcycle\",\n            \"optlev\",\n            \"converge_e\",\n            \"converge_g\",\n            \"freeze\",\n        ]:\n            d[\"calculation\"][k] = v\n        else:\n            d[k] = v\n    d[\"calculation\"][\"level\"] = [\n        calculation_blocks[\"energy\"],\n        calculation_blocks[\"dynamics\"],\n    ]\n    # Check for charges\n    if self.calculation_energy_chrg is None or self.calculation_dynamics_chrg is None:\n        self.calculation_energy_chrg = self.calculation_dynamics_chrg = structure.charge\n\n    with open(\"crest.toml\", \"wb\") as f:\n        tomli_w.dump(d, f)\n\n    # Save current working directory\n    original_dir = os.getcwd()\n\n    # Create temporary directory and run crest there\n    with tempfile.TemporaryDirectory() as tmp_dir:\n        # Copy input files to temp directory\n        shutil.copy(\"input.sdf\", tmp_dir)\n        shutil.copy(\"crest.toml\", tmp_dir)\n\n        # Change to temp directory\n        os.chdir(tmp_dir)\n\n        # Run crest command\n        subprocess.call(\"crest --input crest.toml --noreftopo --mquick &gt; log.out\", shell=True)\n\n        # Copy log.out back to original directory\n        if os.path.exists(\"log.out\"):\n            shutil.copy(\"log.out\", original_dir)\n\n        # Copy all crest_conformers.* files back to original directory\n        for file in glob.glob(\"crest_conformers.xyz\"):\n            shutil.copy(file, original_dir)\n\n        # Change back to original directory\n        os.chdir(original_dir)\n\n    conformers = cast(\n        \"list[SiteCollection]\", XYZ.from_file(\"crest_conformers.xyz\").all_molecules\n    )\n    return conformers, {}\n</code></pre>"},{"location":"conformers/#jfchemistry.conformers.ConformerGeneration","title":"ConformerGeneration  <code>dataclass</code>","text":"<pre><code>ConformerGeneration(name: str = 'Conformer Generation')\n</code></pre> <p>               Bases: <code>SingleStructureMaker</code></p> <p>Base class for conformer generation methods.</p> <p>This abstract class defines the interface for conformer generation implementations. Subclasses should implement the operation() method to generate multiple conformations of the input structure.</p> <p>Conformer generation explores the potential energy surface to find multiple low-energy conformations of a molecule, which is essential for accurately predicting molecular properties that depend on conformational flexibility.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Descriptive name for the conformer generation method.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Subclass implementation\n&gt;&gt;&gt; class MyConformerGenerator(ConformerGeneration):\n...     def operation(self, structure):\n...         # Generate conformers using some method\n...         conformers = generate_conformers(structure)\n...         properties = {\"num_conformers\": len(conformers)}\n...         return conformers, properties\n&gt;&gt;&gt;\n&gt;&gt;&gt; gen = MyConformerGenerator()\n&gt;&gt;&gt; job = gen.make(molecule)\n&gt;&gt;&gt; conformers = job.output[\"structure\"]\n</code></pre>"},{"location":"conformers/#jfchemistry.conformers.ConformerGeneration-functions","title":"Functions","text":""},{"location":"conformers/#jfchemistry.conformers.ConformerGeneration.operation","title":"operation","text":"<pre><code>operation(structure: SiteCollection) -&gt; tuple[SiteCollection | list[SiteCollection], Optional[dict[str, Any]]]\n</code></pre> <p>Generate conformers from the input structure.</p> <p>This method must be implemented by subclasses to perform the actual conformer generation using a specific algorithm or external tool.</p> <p>Parameters:</p> Name Type Description Default <code>structure</code> <code>SiteCollection</code> <p>Input molecular structure with 3D coordinates.</p> required <p>Returns:</p> Type Description <code>tuple[SiteCollection | list[SiteCollection], Optional[dict[str, Any]]]</code> <p>Tuple containing: - List of generated conformer structures (or single structure) - Dictionary of properties from conformer generation (or None)</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>This method must be implemented by subclasses.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # In a subclass\n&gt;&gt;&gt; def operation(self, structure):\n...     conformers = []\n...     for i in range(10):\n...         conf = perform_conformer_search(structure)\n...         conformers.append(conf)\n...     return conformers, {\"method\": \"my_method\"}\n</code></pre> Source code in <code>jfchemistry/conformers/base.py</code> <pre><code>def operation(\n    self, structure: SiteCollection\n) -&gt; tuple[SiteCollection | list[SiteCollection], Optional[dict[str, Any]]]:\n    \"\"\"Generate conformers from the input structure.\n\n    This method must be implemented by subclasses to perform the actual\n    conformer generation using a specific algorithm or external tool.\n\n    Args:\n        structure: Input molecular structure with 3D coordinates.\n\n    Returns:\n        Tuple containing:\n            - List of generated conformer structures (or single structure)\n            - Dictionary of properties from conformer generation (or None)\n\n    Raises:\n        NotImplementedError: This method must be implemented by subclasses.\n\n    Examples:\n        &gt;&gt;&gt; # In a subclass\n        &gt;&gt;&gt; def operation(self, structure):\n        ...     conformers = []\n        ...     for i in range(10):\n        ...         conf = perform_conformer_search(structure)\n        ...         conformers.append(conf)\n        ...     return conformers, {\"method\": \"my_method\"}\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"conformers/#example-usage","title":"Example Usage","text":"<pre><code>from jfchemistry.conformers import CRESTConformers\nfrom jfchemistry.inputs import Smiles\nfrom jfchemistry.generation import RDKitGeneration\n\n# Create molecule and generate initial structure\nsmiles = Smiles()\nsmiles_job = smiles.make(\"CC(C)C(C)C\")  # Branched alkane\n\ngenerator = RDKitGeneration(num_conformers=1)\ngen_job = generator.make(smiles_job.output[\"structure\"])\n\n# Generate conformers with CREST\nconformer_gen = CRESTConformers(\n    runtype=\"imtd-gc\",\n    ewin=6.0,  # Energy window in kcal/mol\n    calculation_energy_method=\"gfnff\",\n    calculation_dynamics_method=\"gfnff\",\n    threads=4\n)\n\njob = conformer_gen.make(gen_job.output[\"structure\"])\n\n# Access results\nconformers = job.output[\"structure\"]  # List of conformers\nproperties = job.output[\"properties\"]\n</code></pre>"},{"location":"conformers/#key-parameters","title":"Key Parameters","text":"<ul> <li>runtype: Type of CREST calculation (e.g., \"imtd-gc\" for iterative metadynamics)</li> <li>ewin: Energy window in kcal/mol for conformer selection</li> <li>calculation_energy_method: Method for energy calculations (e.g., \"gfnff\", \"gfn2\")</li> <li>calculation_dynamics_method: Method for molecular dynamics</li> <li>threads: Number of parallel threads to use</li> </ul>"},{"location":"contributing/","title":"Contributing to JFChemistry","text":"<p>Thank you for your interest in contributing to JFChemistry! This guide will help you get started.</p>"},{"location":"contributing/#ways-to-contribute","title":"Ways to Contribute","text":"<ul> <li>\ud83d\udc1b Report bugs and issues</li> <li>\ud83d\udca1 Suggest new features or enhancements</li> <li>\ud83d\udcdd Improve documentation</li> <li>\ud83e\uddea Add examples and tutorials</li> <li>\ud83d\udd27 Fix bugs or implement features</li> <li>\ud83e\uddea Add new calculators or methods</li> </ul>"},{"location":"contributing/#getting-started","title":"Getting Started","text":""},{"location":"contributing/#1-fork-and-clone","title":"1. Fork and Clone","text":"<pre><code># Fork the repository on GitHub, then clone your fork\ngit clone https://github.com/YOUR-USERNAME/jfchemistry.git\ncd jfchemistry\n</code></pre>"},{"location":"contributing/#2-set-up-development-environment","title":"2. Set Up Development Environment","text":"<pre><code># Install development environment with pixi\npixi install -e dev\n\n# Or install all optional features\npixi install -e aimnet2 -e orb -e dev -e docs\n</code></pre>"},{"location":"contributing/#3-create-a-branch","title":"3. Create a Branch","text":"<pre><code># Create a branch for your changes\ngit checkout -b feature/your-feature-name\n# or\ngit checkout -b fix/your-bugfix-name\n</code></pre>"},{"location":"contributing/#development-workflow","title":"Development Workflow","text":""},{"location":"contributing/#code-style","title":"Code Style","text":"<p>JFChemistry uses Ruff for code formatting and linting:</p> <pre><code># Format code\npixi run -e dev fmt\n\n# Run linter\npixi run -e dev lint\n\n# Type checking\npixi run -e dev types\n</code></pre> <p>All code must:</p> <ul> <li>Follow Google-style docstrings</li> <li>Include type hints</li> <li>Pass ruff formatting and linting</li> <li>Have line length \u2264 100 characters</li> </ul>"},{"location":"contributing/#example-docstring","title":"Example Docstring","text":"<pre><code>def optimize_structure(\n    self,\n    structure: Molecule,\n    fmax: float = 0.01\n) -&gt; tuple[Molecule, dict[str, Any]]:\n    \"\"\"Optimize a molecular structure.\n\n    Performs geometry optimization using the configured method\n    until forces fall below the threshold.\n\n    Args:\n        structure: Pymatgen Molecule to optimize.\n        fmax: Maximum force threshold in eV/\u00c5.\n\n    Returns:\n        Tuple containing:\n            - Optimized Molecule structure\n            - Dictionary of calculated properties\n\n    Raises:\n        CalculationError: If optimization fails to converge.\n\n    Examples:\n        &gt;&gt;&gt; from jfchemistry.optimizers import TBLiteOptimizer\n        &gt;&gt;&gt; optimizer = TBLiteOptimizer(method=\"GFN2-xTB\")\n        &gt;&gt;&gt; opt_mol, props = optimizer.optimize_structure(molecule)\n    \"\"\"\n</code></pre>"},{"location":"contributing/#testing","title":"Testing","text":"<p>Write tests for new features:</p> <pre><code># Run all tests\npixi run -e dev test\n\n# Run specific test file\npixi run -e dev pytest tests/test_your_feature.py\n\n# Run with coverage\npixi run -e dev pytest --cov=jfchemistry\n</code></pre> <p>Tests should:</p> <ul> <li>Cover main functionality</li> <li>Include edge cases</li> <li>Use doctests for simple examples</li> <li>Mock external dependencies when appropriate</li> </ul>"},{"location":"contributing/#documentation","title":"Documentation","text":"<p>Update documentation for changes:</p> <pre><code># Build documentation locally\npixi run -e docs mkdocs serve\n\n# View at http://127.0.0.1:8000\n</code></pre> <p>Documentation updates should include:</p> <ul> <li>Updated docstrings in code</li> <li>Examples in relevant <code>.md</code> files</li> <li>Updates to User Guide if needed</li> <li>FAQ entries for common questions</li> </ul>"},{"location":"contributing/#adding-new-features","title":"Adding New Features","text":""},{"location":"contributing/#adding-a-new-calculator","title":"Adding a New Calculator","text":"<ol> <li>Create a new file in <code>jfchemistry/calculators/</code>:</li> </ol> <pre><code># jfchemistry/calculators/my_calculator.py\nfrom jfchemistry.calculators import ASECalculator\n\nclass MyCalculator(ASECalculator):\n    \"\"\"Calculator using My Method.\n\n    Attributes:\n        parameter1: Description of parameter1.\n        parameter2: Description of parameter2.\n    \"\"\"\n\n    def __init__(self, parameter1: str = \"default\"):\n        \"\"\"Initialize My Calculator.\n\n        Args:\n            parameter1: Description and purpose.\n        \"\"\"\n        self.parameter1 = parameter1\n\n    def set_calculator(self, atoms, charge=0, spin_multiplicity=1):\n        \"\"\"Set up the ASE calculator.\"\"\"\n        # Implementation\n        pass\n\n    def get_properties(self, atoms):\n        \"\"\"Extract properties from calculation.\"\"\"\n        # Implementation\n        pass\n</code></pre> <ol> <li>Add to <code>jfchemistry/calculators/__init__.py</code>:</li> </ol> <pre><code>from .my_calculator import MyCalculator\n\n__all__ = [..., \"MyCalculator\"]\n</code></pre> <ol> <li> <p>Add tests in <code>tests/test_calculators.py</code></p> </li> <li> <p>Add documentation example</p> </li> </ol>"},{"location":"contributing/#adding-a-new-optimizer","title":"Adding a New Optimizer","text":"<p>Similar process in <code>jfchemistry/optimizers/</code>:</p> <pre><code>from jfchemistry.optimizers.base import GeometryOptimization\n\nclass MyOptimizer(GeometryOptimization):\n    \"\"\"Optimizer using My Method.\"\"\"\n\n    def optimize_structure(self, structure):\n        \"\"\"Optimize the structure.\"\"\"\n        # Implementation\n        pass\n</code></pre>"},{"location":"contributing/#adding-examples","title":"Adding Examples","text":"<p>Add examples to <code>examples/</code> directory:</p> <pre><code># examples/my_example.py\n\"\"\"\nExample: Doing Something Cool\n\nThis example demonstrates how to...\n\"\"\"\n\nfrom jfchemistry.inputs import Smiles\n# ... rest of example\n\nif __name__ == \"__main__\":\n    # Runnable code\n    pass\n</code></pre>"},{"location":"contributing/#pull-request-process","title":"Pull Request Process","text":""},{"location":"contributing/#1-before-submitting","title":"1. Before Submitting","text":"<ul> <li> Code passes all tests</li> <li> Code is formatted with ruff</li> <li> Docstrings are complete and accurate</li> <li> Documentation is updated</li> <li> CHANGELOG is updated (if applicable)</li> <li> Commits are clear and descriptive</li> </ul>"},{"location":"contributing/#2-submit-pull-request","title":"2. Submit Pull Request","text":"<ol> <li>Push your branch to your fork:</li> </ol> <pre><code>git push origin feature/your-feature-name\n</code></pre> <ol> <li> <p>Open a Pull Request on GitHub</p> </li> <li> <p>Fill out the PR template:</p> </li> </ol> <pre><code>## Description\n\nBrief description of changes\n\n## Type of Change\n\n-   [ ] Bug fix\n-   [ ] New feature\n-   [ ] Documentation update\n-   [ ] Performance improvement\n\n## Testing\n\nHow was this tested?\n\n## Checklist\n\n-   [ ] Code follows style guidelines\n-   [ ] Tests pass\n-   [ ] Documentation updated\n-   [ ] Self-reviewed code\n</code></pre>"},{"location":"contributing/#3-code-review","title":"3. Code Review","text":"<ul> <li>Address reviewer feedback</li> <li>Keep discussion focused and professional</li> <li>Be open to suggestions</li> </ul>"},{"location":"contributing/#4-merging","title":"4. Merging","text":"<p>Once approved:</p> <ul> <li>Maintainer will merge your PR</li> <li>Your changes will be included in the next release</li> </ul>"},{"location":"contributing/#commit-message-guidelines","title":"Commit Message Guidelines","text":"<p>Use clear, descriptive commit messages:</p> <pre><code># Good\ngit commit -m \"Add AimNet2 calculator for neural network potentials\"\ngit commit -m \"Fix conformer generation memory leak\"\ngit commit -m \"Update documentation for TBLite optimizer\"\n\n# Bad\ngit commit -m \"fix stuff\"\ngit commit -m \"wip\"\ngit commit -m \"asdf\"\n</code></pre> <p>Format:</p> <pre><code>&lt;type&gt;: &lt;subject&gt;\n\n[optional body]\n\n[optional footer]\n</code></pre> <p>Types:</p> <ul> <li><code>feat</code>: New feature</li> <li><code>fix</code>: Bug fix</li> <li><code>docs</code>: Documentation changes</li> <li><code>style</code>: Code style (formatting, etc.)</li> <li><code>refactor</code>: Code refactoring</li> <li><code>test</code>: Adding/updating tests</li> <li><code>chore</code>: Maintenance tasks</li> </ul>"},{"location":"contributing/#project-structure","title":"Project Structure","text":"<pre><code>jfchemistry/\n\u251c\u2500\u2500 jfchemistry/           # Source code\n\u2502   \u251c\u2500\u2500 calculators/       # Calculator implementations\n\u2502   \u251c\u2500\u2500 conformers/        # Conformer generation\n\u2502   \u251c\u2500\u2500 generation/        # 3D structure generation\n\u2502   \u251c\u2500\u2500 inputs/            # Input parsers\n\u2502   \u251c\u2500\u2500 modification/      # Structure modification\n\u2502   \u251c\u2500\u2500 optimizers/        # Geometry optimizers\n\u2502   \u2514\u2500\u2500 jfchemistry.py     # Core classes\n\u251c\u2500\u2500 tests/                 # Test files\n\u251c\u2500\u2500 docs/                  # Documentation source\n\u251c\u2500\u2500 examples/              # Example scripts\n\u2514\u2500\u2500 pyproject.toml         # Project configuration\n</code></pre>"},{"location":"contributing/#best-practices","title":"Best Practices","text":""},{"location":"contributing/#1-keep-changes-focused","title":"1. Keep Changes Focused","text":"<ul> <li>One feature/fix per PR</li> <li>Keep PRs reasonably sized</li> <li>Split large changes into multiple PRs</li> </ul>"},{"location":"contributing/#2-write-good-tests","title":"2. Write Good Tests","text":"<pre><code>def test_optimizer_convergence():\n    \"\"\"Test that optimizer converges for simple molecule.\"\"\"\n    # Arrange\n    molecule = create_test_molecule()\n    optimizer = TBLiteOptimizer(fmax=0.01)\n\n    # Act\n    job = optimizer.make(molecule)\n    result = job.output\n\n    # Assert\n    assert result[\"structure\"] is not None\n    assert result[\"properties\"][\"converged\"] is True\n</code></pre>"},{"location":"contributing/#3-document-public-apis","title":"3. Document Public APIs","text":"<p>Every public class, method, and function needs:</p> <ul> <li>Concise summary line</li> <li>Detailed description</li> <li>Args documentation</li> <li>Returns documentation</li> <li>Examples (when helpful)</li> </ul>"},{"location":"contributing/#4-handle-errors-gracefully","title":"4. Handle Errors Gracefully","text":"<pre><code>try:\n    result = calculation()\nexcept CalculationError as e:\n    logger.error(f\"Calculation failed: {e}\")\n    raise\n</code></pre>"},{"location":"contributing/#questions","title":"Questions?","text":"<ul> <li>Open an issue for questions</li> <li>Join discussions on GitHub</li> <li>Check existing issues and PRs</li> </ul>"},{"location":"contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>Be respectful and constructive. We're all here to advance computational chemistry!</p> <p>Thank you for contributing! \ud83c\udf89</p>"},{"location":"faq/","title":"Frequently Asked Questions","text":"<p>Disclaimer</p> <p>These are Claude 4.5 Sonnet generated questions and answers. Ask more questions and file issues to populate this page with accurate FAQs.</p>"},{"location":"faq/#installation","title":"Installation","text":""},{"location":"faq/#q-why-do-i-get-crest-not-found-errors","title":"Q: Why do I get \"CREST not found\" errors?","text":"<p>A: CREST should be installed automatically with the default pixi environment. Make sure you've run:</p> <pre><code>pixi install\n</code></pre> <p>If you still have issues, check that CREST is in your PATH:</p> <pre><code>which crest\n</code></pre>"},{"location":"faq/#q-can-i-use-jfchemistry-without-pixi","title":"Q: Can I use jfchemistry without Pixi?","text":"<p>A: While Pixi is the recommended way to manage dependencies, you can install jfchemistry with pip:</p> <pre><code>pip install -e .\n</code></pre> <p>However, you'll need to manually install system dependencies like CREST, OpenBabel, etc.</p>"},{"location":"faq/#q-which-optional-features-should-i-install","title":"Q: Which optional features should I install?","text":"<p>A: It depends on your needs:</p> <ul> <li>aimnet2: Fast neural network potential for accurate energies</li> <li>orb: Machine learning force fields for materials</li> <li>dev: Development tools (testing, linting)</li> <li>docs: Documentation building tools</li> </ul>"},{"location":"faq/#usage","title":"Usage","text":""},{"location":"faq/#q-how-do-i-process-multiple-molecules-in-parallel","title":"Q: How do I process multiple molecules in parallel?","text":"<p>A: JFChemistry automatically parallelizes when you pass lists of molecules:</p> <pre><code># This will process all structures in parallel\nmolecules = [mol1, mol2, mol3]\noptimizer = TBLiteOptimizer()\njob = optimizer.make(molecules)\n</code></pre>"},{"location":"faq/#q-whats-the-difference-between-singlemoleculemaker-and-singlestructuremaker","title":"Q: What's the difference between SingleMoleculeMaker and SingleStructureMaker?","text":"<p>A:</p> <ul> <li>SingleMoleculeMaker: For RDKit molecules without 3D coordinates (e.g., from SMILES)</li> <li>SingleStructureMaker: For Pymatgen structures with 3D coordinates</li> </ul> <p>The workflow typically flows: SMILES \u2192 RDMolMolecule \u2192 3D Structure \u2192 Optimization</p>"},{"location":"faq/#q-how-do-i-choose-between-different-optimization-methods","title":"Q: How do I choose between different optimization methods?","text":"<p>A: Here's a quick guide:</p> Method Speed Accuracy Use Case GFN-FF Fast Low Quick pre-optimization GFN2-xTB Medium Medium General purpose, production AimNet2 Fast High Accurate energies, charges ORB Fast High Materials, periodic systems"},{"location":"faq/#q-can-i-use-custom-ase-calculators","title":"Q: Can I use custom ASE calculators?","text":"<p>A: Yes! Use the ASEOptimizer base class:</p> <pre><code>from jfchemistry.optimizers import ASEOptimizer\nfrom your_calculator import YourCalculator\n\noptimizer = ASEOptimizer(\n    calculator=YourCalculator(),\n    fmax=0.01,\n    steps=1000\n)\n</code></pre>"},{"location":"faq/#performance","title":"Performance","text":""},{"location":"faq/#q-how-can-i-speed-up-conformer-generation","title":"Q: How can I speed up conformer generation?","text":"<p>A: Several strategies:</p> <ol> <li>Use RDKit for initial generation (fast but less thorough)</li> <li>Use CREST with GFN-FF instead of GFN2 for speed</li> <li>Reduce the energy window (<code>ewin</code> parameter)</li> <li>Increase the number of threads</li> </ol> <pre><code># Fast conformer search\nconformer_gen = CRESTConformers(\n    runtype=\"imtd-gc\",\n    ewin=4.0,  # Smaller window = fewer conformers\n    calculation_energy_method=\"gfnff\",  # Faster than gfn2\n    threads=8  # Use more cores\n)\n</code></pre>"},{"location":"faq/#q-my-optimization-is-taking-too-long-what-can-i-do","title":"Q: My optimization is taking too long. What can I do?","text":"<p>A: Try a multi-level approach:</p> <pre><code># Quick pre-optimization with force field\npre_opt = TBLiteOptimizer(method=\"GFNFF\", fmax=0.1)\npre_job = pre_opt.make(structure)\n\n# Refine with better method\nfinal_opt = TBLiteOptimizer(method=\"GFN2-xTB\", fmax=0.01)\nfinal_job = final_opt.make(pre_job.output[\"structure\"])\n</code></pre>"},{"location":"faq/#q-how-much-memory-do-i-need","title":"Q: How much memory do I need?","text":"<p>A: Depends on molecule size and method:</p> <ul> <li>Small molecules (&lt;20 atoms): 1-2 GB</li> <li>Medium molecules (20-50 atoms): 2-8 GB</li> <li>Large molecules (&gt;50 atoms): 8+ GB</li> <li>AimNet2/ORB: Additional 2-4 GB for model loading</li> </ul>"},{"location":"faq/#output-results","title":"Output &amp; Results","text":""},{"location":"faq/#q-how-do-i-save-optimized-structures","title":"Q: How do I save optimized structures?","text":"<p>A: Use Pymatgen's <code>to()</code> method:</p> <pre><code>structure = job.output[\"structure\"]\nstructure.to(filename=\"optimized.xyz\")\nstructure.to(filename=\"optimized.mol\")\n\n# For ASE formats\nfrom pymatgen.io.ase import AseAtomsAdaptor\natoms = AseAtomsAdaptor.get_atoms(structure)\natoms.write(\"optimized.pdb\")\n</code></pre>"},{"location":"faq/#q-what-properties-are-calculated","title":"Q: What properties are calculated?","text":"<p>A: Depends on the calculator, but typically includes:</p> <ul> <li>Global: Total energy, dipole moment</li> <li>Orbital: HOMO, LUMO, gap (for xTB methods)</li> <li>Atomic: Charges, forces</li> <li>Vibrational: Frequencies (if requested)</li> </ul> <p>Access via:</p> <pre><code>properties = job.output[\"properties\"]\nenergy = properties[\"Global\"][\"Total Energy [Eh]\"]\n</code></pre>"},{"location":"faq/#q-can-i-visualize-the-structures","title":"Q: Can I visualize the structures?","text":"<p>A: Yes! Use standard chemistry visualization tools:</p> <pre><code>from pymatgen.io.ase import AseAtomsAdaptor\nfrom ase.visualize import view\n\natoms = AseAtomsAdaptor.get_atoms(structure)\nview(atoms)  # Opens ASE GUI\n</code></pre> <p>Or export to formats for external viewers (Avogadro, PyMOL, etc.):</p> <pre><code>structure.to(filename=\"molecule.xyz\")  # Open in Avogadro\natoms.write(\"molecule.pdb\")  # Open in PyMOL\n</code></pre>"},{"location":"faq/#errors-debugging","title":"Errors &amp; Debugging","text":""},{"location":"faq/#q-i-get-calculator-failed-errors-whats-wrong","title":"Q: I get \"Calculator failed\" errors. What's wrong?","text":"<p>A: Common causes:</p> <ol> <li>Invalid geometry: Try pre-optimization with GFN-FF</li> <li>Wrong charge/multiplicity: Check molecular charge and spin</li> <li>SCF convergence: Some molecules need different settings</li> <li>Memory: Reduce molecule size or increase available RAM</li> </ol>"},{"location":"faq/#q-crest-jobs-fail-silently-how-do-i-debug","title":"Q: CREST jobs fail silently. How do I debug?","text":"<p>A: Check the working directory for CREST output files:</p> <pre><code># CREST writes to temporary directories\n# Look for crest_*.out files for error messages\n</code></pre> <p>Enable verbose output in your workflow setup.</p>"},{"location":"faq/#q-how-do-i-handle-charged-or-radical-species","title":"Q: How do I handle charged or radical species?","text":"<p>A: Set the charge and spin multiplicity:</p> <pre><code># For H3O+ (charge=+1, singlet)\noptimizer = TBLiteOptimizer(\n    method=\"GFN2-xTB\",\n    charge=1,\n    spin_multiplicity=1\n)\n\n# For O2 (charge=0, triplet)\noptimizer = TBLiteOptimizer(\n    method=\"GFN2-xTB\",\n    charge=0,\n    spin_multiplicity=3\n)\n</code></pre>"},{"location":"faq/#workflows","title":"Workflows","text":""},{"location":"faq/#q-can-i-integrate-jfchemistry-with-jobflowfireworks","title":"Q: Can I integrate jfchemistry with jobflow/FireWorks?","text":"<p>A: Yes! JFChemistry is built on jobflow:</p> <pre><code>from jobflow import Flow, run_locally\n\n# Create workflow\njobs = [job1, job2, job3]\nflow = Flow(jobs)\n\n# Run locally\nrun_locally(flow)\n\n# Or submit to FireWorks\n# (requires FireWorks setup)\n</code></pre>"},{"location":"faq/#q-how-do-i-chain-multiple-operations","title":"Q: How do I chain multiple operations?","text":"<p>A: Jobs can be chained by referencing outputs:</p> <pre><code>smiles_job = Smiles().make(\"CCO\")\ngen_job = RDKitGeneration().make(smiles_job.output[\"structure\"])\nopt_job = TBLiteOptimizer().make(gen_job.output[\"structure\"])\n</code></pre> <p>The workflow manager handles dependencies automatically.</p>"},{"location":"faq/#contributing","title":"Contributing","text":""},{"location":"faq/#q-how-can-i-add-a-new-calculator","title":"Q: How can I add a new calculator?","text":"<p>A: Create a subclass of <code>ASECalculator</code>:</p> <pre><code>from jfchemistry.calculators import ASECalculator\n\nclass MyCalculator(ASECalculator):\n    def set_calculator(self, atoms, charge=0, spin_multiplicity=1):\n        # Set up your calculator\n        calc = YourASECalculator(...)\n        atoms.calc = calc\n        return atoms\n\n    def get_properties(self, atoms):\n        # Extract properties\n        return {\n            \"Global\": {\n                \"Total Energy [eV]\": atoms.get_potential_energy(),\n                # ...\n            }\n        }\n</code></pre>"},{"location":"faq/#q-how-do-i-report-bugs","title":"Q: How do I report bugs?","text":"<p>A: Open an issue on GitHub with:</p> <ol> <li>Minimal code example to reproduce</li> <li>Error message/traceback</li> <li>Environment info (Python version, OS, etc.)</li> <li>Expected vs actual behavior</li> </ol>"},{"location":"faq/#q-can-i-contribute-examples","title":"Q: Can I contribute examples?","text":"<p>A: Absolutely! Submit a PR with:</p> <ol> <li>Working example code</li> <li>Brief description of what it demonstrates</li> <li>Any special requirements or dependencies</li> </ol> <p>Place in the <code>examples/</code> directory.</p>"},{"location":"faq/#getting-help","title":"Getting Help","text":"<p>Still stuck? Try these resources:</p> <ul> <li>GitHub Issues: github.com/cfarm6/jfchemistry/issues</li> <li>Jobflow Docs: materialsproject.github.io/jobflow</li> <li>ASE Docs: wiki.fysik.dtu.dk/ase</li> </ul>"},{"location":"generation/","title":"3D Structure Generation","text":"<p>Structure generation methods convert molecular representations without 3D coordinates (like SMILES strings or molecular graphs) into 3D structures with embedded conformers.</p> <p>options: show_root_heading: true show_source: true show_root_toc_entry: true members: true show_bases: true show_inheritance_diagram: true</p>"},{"location":"generation/#jfchemistry.generation","title":"generation","text":"<p>3D structure generation from molecular representations.</p> <p>This module provides tools for generating 3D molecular structures from representations without explicit coordinates (e.g., SMILES, molecular graphs).</p> Available Methods <ul> <li>StructureGeneration: Base class for structure generation</li> <li>RDKitGeneration: Generate 3D structures using RDKit's embedding methods</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from jfchemistry.inputs import Smiles\n&gt;&gt;&gt; from jfchemistry.generation import RDKitGeneration\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Get molecule from SMILES\n&gt;&gt;&gt; smiles_job = Smiles().make(\"CCO\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Generate 3D structures\n&gt;&gt;&gt; gen = RDKitGeneration(\n...     method=\"ETKDGv3\",\n...     num_conformers=10,\n...     prune_rms_thresh=0.5\n... )\n&gt;&gt;&gt; job = gen.make(smiles_job.output[\"structure\"])\n&gt;&gt;&gt; structures = job.output[\"structure\"]\n</code></pre>"},{"location":"generation/#jfchemistry.generation-classes","title":"Classes","text":""},{"location":"generation/#jfchemistry.generation.RDKitGeneration","title":"RDKitGeneration  <code>dataclass</code>","text":"<pre><code>RDKitGeneration(name: str = 'rdKit Generation', check_structure: bool = False, method: Literal['ETDG', 'ETKDG', 'ETKDGv2', 'ETKDGv3', 'KDG', 'srETKDGv3'] = 'ETKDGv3', basin_thresh: Optional[float] = None, bounds_mat_force_scaling: Optional[float] = None, box_size_mult: Optional[float] = None, clear_confs: Optional[bool] = None, embed_fragments_separately: Optional[bool] = None, enable_sequential_random_seeds: Optional[bool] = None, enforce_chirality: Optional[bool] = None, force_trans_amides: Optional[bool] = None, ignore_smoothing_failures: Optional[bool] = None, max_iterations: Optional[Annotated[int, positive]] = None, num_threads: Annotated[int, positive] = 1, num_zero_fail: Optional[Annotated[int, positive]] = None, only_heavy_atoms_for_rms: Optional[bool] = None, optimizer_force_tol: Optional[float] = None, prune_rms_thresh: Optional[float] = None, rand_neg_eig: Optional[bool] = None, random_seed: Optional[Annotated[int, positive]] = None, symmetrize_conjugated_terminal_groups_for_pruning: Optional[bool] = None, timeout: Optional[Annotated[int, positive]] = None, track_failures: Optional[bool] = None, use_basic_knowledge: Optional[bool] = None, use_exp_torsion_angle_prefs: Optional[bool] = None, use_macrocycle_14config: Optional[bool] = None, use_macrocycle_torsions: Optional[bool] = None, use_random_coords: Optional[bool] = None, use_small_ring_torsions: Optional[bool] = None, use_symmetry_for_pruning: Optional[bool] = None, num_conformers: Annotated[int, positive] = 1)\n</code></pre> <p>               Bases: <code>StructureGeneration</code></p> <p>Generate 3D structures using RDKit distance geometry methods.</p> <p>This class uses RDKit's distance geometry embedding algorithms (ETKDG family) to generate 3D conformers from molecular graphs. The methods use distance bounds derived from experimental torsion angle preferences and small ring conformations to produce chemically reasonable 3D structures.</p> <p>The implementation supports all RDKit embedding parameters, allowing fine control over the generation process including optimization settings, pruning criteria, and random seed control.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the job (default: \"rdKit Generation\").</p> <code>method</code> <code>Literal['ETDG', 'ETKDG', 'ETKDGv2', 'ETKDGv3', 'KDG', 'srETKDGv3']</code> <p>Distance geometry method to use: - \"ETKDGv3\": ETKDG version 3 (default, recommended) - \"ETKDGv2\": ETKDG version 2 - \"ETKDG\": Original ETKDG method - \"ETDG\": Experimental torsion distance geometry - \"KDG\": Basic distance geometry - \"srETKDGv3\": Small ring ETKDG version 3</p> <code>basin_thresh</code> <code>Optional[float]</code> <p>Energy threshold for basin hopping (default: None).</p> <code>bounds_mat_force_scaling</code> <code>Optional[float]</code> <p>Scaling factor for distance bounds (default: None).</p> <code>box_size_mult</code> <code>Optional[float]</code> <p>Box size multiplier for embedding (default: None).</p> <code>clear_confs</code> <code>Optional[bool]</code> <p>Clear existing conformers before embedding (default: None).</p> <code>embed_fragments_separately</code> <code>Optional[bool]</code> <p>Embed molecular fragments separately (default: None).</p> <code>enable_sequential_random_seeds</code> <code>Optional[bool]</code> <p>Use sequential random seeds (default: None).</p> <code>enforce_chirality</code> <code>Optional[bool]</code> <p>Enforce stereochemistry from molecular graph (default: None).</p> <code>force_trans_amides</code> <code>Optional[bool]</code> <p>Force amide bonds to trans configuration (default: None).</p> <code>ignore_smoothing_failures</code> <code>Optional[bool]</code> <p>Continue if smoothing fails (default: None).</p> <code>max_iterations</code> <code>Optional[Annotated[int, positive]]</code> <p>Maximum optimization iterations per conformer (default: None).</p> <code>num_threads</code> <code>Annotated[int, positive]</code> <p>Number of parallel threads for embedding (default: 1).</p> <code>num_zero_fail</code> <code>Optional[Annotated[int, positive]]</code> <p>Number of failures before reporting (default: None).</p> <code>only_heavy_atoms_for_rms</code> <code>Optional[bool]</code> <p>Use only heavy atoms for RMSD pruning (default: None).</p> <code>optimizer_force_tol</code> <code>Optional[float]</code> <p>Force tolerance for optimization (default: None).</p> <code>prune_rms_thresh</code> <code>Optional[float]</code> <p>RMSD threshold for conformer pruning in Angstroms (default: None).</p> <code>rand_neg_eig</code> <code>Optional[bool]</code> <p>Randomize negative eigenvalues (default: None).</p> <code>random_seed</code> <code>Optional[Annotated[int, positive]]</code> <p>Random seed for reproducibility (default: None).</p> <code>symmetrize_conjugated_terminal_groups_for_pruning</code> <code>Optional[bool]</code> <p>Symmetrize terminal groups for RMSD calculations (default: None).</p> <code>timeout</code> <code>Optional[Annotated[int, positive]]</code> <p>Timeout in seconds for embedding (default: None).</p> <code>track_failures</code> <code>Optional[bool]</code> <p>Track embedding failures (default: None).</p> <code>use_basic_knowledge</code> <code>Optional[bool]</code> <p>Use basic chemical knowledge (default: None).</p> <code>use_exp_torsion_angle_prefs</code> <code>Optional[bool]</code> <p>Use experimental torsion preferences (default: None).</p> <code>use_macrocycle_14config</code> <code>Optional[bool]</code> <p>Use 1,4 distance bounds for macrocycles (default: None).</p> <code>use_macrocycle_torsions</code> <code>Optional[bool]</code> <p>Use macrocycle torsion preferences (default: None).</p> <code>use_random_coords</code> <code>Optional[bool]</code> <p>Start from random coordinates (default: None).</p> <code>use_small_ring_torsions</code> <code>Optional[bool]</code> <p>Use small ring torsion preferences (default: None).</p> <code>use_symmetry_for_pruning</code> <code>Optional[bool]</code> <p>Use symmetry when pruning conformers (default: None).</p> <code>num_conformers</code> <code>Annotated[int, positive]</code> <p>Number of conformers to generate (default: 1).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from jfchemistry.inputs import Smiles\n&gt;&gt;&gt; from jfchemistry.generation import RDKitGeneration\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Get molecule from SMILES\n&gt;&gt;&gt; smiles_job = Smiles().make(\"c1ccccc1\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Generate single low-energy conformer\n&gt;&gt;&gt; gen_single = RDKitGeneration(\n...     method=\"ETKDGv3\",\n...     num_conformers=1,\n...     random_seed=42\n... )\n&gt;&gt;&gt; job = gen_single.make(smiles_job.output[\"structure\"])\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Generate diverse conformer ensemble\n&gt;&gt;&gt; gen_ensemble = RDKitGeneration(\n...     method=\"ETKDGv3\",\n...     num_conformers=100,\n...     prune_rms_thresh=0.5,  # Remove similar conformers\n...     max_iterations=500,\n...     num_threads=4\n... )\n&gt;&gt;&gt; job = gen_ensemble.make(smiles_job.output[\"structure\"])\n&gt;&gt;&gt; conformers = job.output[\"structure\"]\n</code></pre>"},{"location":"generation/#jfchemistry.generation.RDKitGeneration-functions","title":"Functions","text":""},{"location":"generation/#jfchemistry.generation.RDKitGeneration.operation","title":"operation","text":"<pre><code>operation(mol: RDMolMolecule) -&gt; tuple[SiteCollection | list[SiteCollection], dict[str, Any]]\n</code></pre> <p>Generate 3D structure(s) using RDKit distance geometry embedding.</p> <p>Embeds 3D coordinates into the molecule using the specified ETKDG method and parameters. Automatically configures the RDKit embedding parameters from the instance attributes and generates the requested number of conformers.</p> <p>The method: 1. Creates RDKit embedding parameters object for the selected method 2. Transfers all non-None attributes to the parameters 3. Embeds conformers using distance geometry 4. Converts conformers to Pymatgen Molecule objects 5. Sets charge and spin multiplicity based on formal charge</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>RDMolMolecule</code> <p>RDKit molecule without 3D coordinates.</p> required <p>Returns:</p> Type Description <code>tuple[SiteCollection | list[SiteCollection], dict[str, Any]]</code> <p>Tuple containing: - List of Pymatgen Molecule objects with 3D coordinates - Empty dictionary (no additional properties)</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from rdkit import Chem\n&gt;&gt;&gt; from jfchemistry import RDMolMolecule\n&gt;&gt;&gt; from jfchemistry.generation import RDKitGeneration\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Create molecule from SMILES\n&gt;&gt;&gt; mol = Chem.MolFromSmiles(\"CCO\")\n&gt;&gt;&gt; rdmol = RDMolMolecule(Chem.AddHs(mol))\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Generate 10 conformers\n&gt;&gt;&gt; gen = RDKitGeneration(num_conformers=10, random_seed=42)\n&gt;&gt;&gt; structures, props = gen.operation(rdmol)\n&gt;&gt;&gt; print(f\"Generated {len(structures)} conformers\")\nGenerated 10 conformers\n</code></pre> Source code in <code>jfchemistry/generation/rdkit_generation.py</code> <pre><code>def operation(\n    self, mol: RDMolMolecule\n) -&gt; tuple[SiteCollection | list[SiteCollection], dict[str, Any]]:\n    \"\"\"Generate 3D structure(s) using RDKit distance geometry embedding.\n\n    Embeds 3D coordinates into the molecule using the specified ETKDG method\n    and parameters. Automatically configures the RDKit embedding parameters\n    from the instance attributes and generates the requested number of conformers.\n\n    The method:\n    1. Creates RDKit embedding parameters object for the selected method\n    2. Transfers all non-None attributes to the parameters\n    3. Embeds conformers using distance geometry\n    4. Converts conformers to Pymatgen Molecule objects\n    5. Sets charge and spin multiplicity based on formal charge\n\n    Args:\n        mol: RDKit molecule without 3D coordinates.\n\n    Returns:\n        Tuple containing:\n            - List of Pymatgen Molecule objects with 3D coordinates\n            - Empty dictionary (no additional properties)\n\n    Examples:\n        &gt;&gt;&gt; from rdkit import Chem\n        &gt;&gt;&gt; from jfchemistry import RDMolMolecule\n        &gt;&gt;&gt; from jfchemistry.generation import RDKitGeneration\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Create molecule from SMILES\n        &gt;&gt;&gt; mol = Chem.MolFromSmiles(\"CCO\")\n        &gt;&gt;&gt; rdmol = RDMolMolecule(Chem.AddHs(mol))\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Generate 10 conformers\n        &gt;&gt;&gt; gen = RDKitGeneration(num_conformers=10, random_seed=42)\n        &gt;&gt;&gt; structures, props = gen.operation(rdmol)\n        &gt;&gt;&gt; print(f\"Generated {len(structures)} conformers\")\n        Generated 10 conformers\n    \"\"\"\n    import inspect\n\n    from rdkit.Chem import rdDistGeom, rdmolfiles, rdmolops\n\n    params = getattr(rdDistGeom, self.method)()\n    param_keys = [x[0] for x in inspect.getmembers(params)]\n    for key, value in vars(self).items():\n\n        def _to_camel_case(s: str) -&gt; str:\n            parts = s.split(\"_\")\n            return parts[0] + \"\".join(word.capitalize() for word in parts[1:])\n\n        camel_key = _to_camel_case(key)\n        if camel_key not in param_keys or value is None:\n            continue\n        setattr(params, camel_key, value)\n    rdDistGeom.EmbedMultipleConfs(mol, self.num_conformers, params)\n    molecules: list[SiteCollection] = []\n    for confId in range(mol.GetNumConformers()):\n        molecule: Molecule = Molecule.from_str(\n            rdmolfiles.MolToV3KMolBlock(mol, confId=int(confId)),\n            fmt=\"sdf\",  # type: ignore[arg-type]\n        )\n        charge = rdmolops.GetFormalCharge(mol)\n        spin = int(2 * (abs(charge) // 2) + 1)\n        molecule.set_charge_and_spin(charge, spin)\n        molecules.append(molecule)\n\n    return molecules, {}\n</code></pre>"},{"location":"generation/#jfchemistry.generation.StructureGeneration","title":"StructureGeneration  <code>dataclass</code>","text":"<pre><code>StructureGeneration(name: str = 'Structure Generation', check_structure: bool = False)\n</code></pre> <p>               Bases: <code>SingleMoleculeMaker</code></p> <p>Base class for generating 3D structures from RDKit molecules.</p> <p>This abstract class defines the interface for structure generation implementations that convert RDKit molecular representations (without 3D coordinates) into Pymatgen structures with explicit 3D coordinates.</p> <p>Subclasses should implement the operation() method to perform the actual embedding/generation using specific algorithms (e.g., distance geometry, force fields, or machine learning models).</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Descriptive name for the structure generation method.</p> <code>check_structure</code> <code>bool</code> <p>Whether to validate the generated structure using PoseBusters or similar validation tools (default: False).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Subclass implementation\n&gt;&gt;&gt; class MyGenerator(StructureGeneration):\n...     def operation(self, structure):\n...         # Embed 3D coordinates\n...         mol_3d = embed_molecule(structure)\n...         properties = {\"method\": \"my_embedding\"}\n...         return mol_3d, properties\n&gt;&gt;&gt;\n&gt;&gt;&gt; gen = MyGenerator()\n&gt;&gt;&gt; job = gen.make(rdmol)\n&gt;&gt;&gt; structure = job.output[\"structure\"]\n</code></pre>"},{"location":"generation/#jfchemistry.generation.StructureGeneration-functions","title":"Functions","text":""},{"location":"generation/#jfchemistry.generation.StructureGeneration.operation","title":"operation","text":"<pre><code>operation(structure: RDMolMolecule) -&gt; tuple[SiteCollection | list[SiteCollection], dict[str, Any]]\n</code></pre> <p>Generate 3D structure(s) from an RDKit molecule.</p> <p>This method must be implemented by subclasses to perform the actual 3D coordinate generation using a specific algorithm.</p> <p>Parameters:</p> Name Type Description Default <code>structure</code> <code>RDMolMolecule</code> <p>RDKit molecule without 3D coordinates.</p> required <p>Returns:</p> Type Description <code>tuple[SiteCollection | list[SiteCollection], dict[str, Any]]</code> <p>Tuple containing: - Generated 3D structure(s) as Pymatgen SiteCollection(s) - Dictionary of properties from the generation process</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>This method must be implemented by subclasses.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # In a subclass\n&gt;&gt;&gt; def operation(self, structure):\n...     # Generate 3D coordinates\n...     structure_3d = generate_3d(structure)\n...     props = {\"energy\": -123.45, \"rmsd\": 0.12}\n...     return structure_3d, props\n</code></pre> Source code in <code>jfchemistry/generation/base.py</code> <pre><code>def operation(\n    self, structure: RDMolMolecule\n) -&gt; tuple[SiteCollection | list[SiteCollection], dict[str, Any]]:\n    \"\"\"Generate 3D structure(s) from an RDKit molecule.\n\n    This method must be implemented by subclasses to perform the actual\n    3D coordinate generation using a specific algorithm.\n\n    Args:\n        structure: RDKit molecule without 3D coordinates.\n\n    Returns:\n        Tuple containing:\n            - Generated 3D structure(s) as Pymatgen SiteCollection(s)\n            - Dictionary of properties from the generation process\n\n    Raises:\n        NotImplementedError: This method must be implemented by subclasses.\n\n    Examples:\n        &gt;&gt;&gt; # In a subclass\n        &gt;&gt;&gt; def operation(self, structure):\n        ...     # Generate 3D coordinates\n        ...     structure_3d = generate_3d(structure)\n        ...     props = {\"energy\": -123.45, \"rmsd\": 0.12}\n        ...     return structure_3d, props\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"generation/#example-usage","title":"Example Usage","text":"<pre><code>from jfchemistry.inputs import Smiles\nfrom jfchemistry.generation import RDKitGeneration\n\n# Create molecule from SMILES\nsmiles = Smiles(add_hydrogens=True)\nsmiles_job = smiles.make(\"c1ccccc1\")  # Benzene\n\n# Generate multiple 3D conformers\ngenerator = RDKitGeneration(\n    method=\"ETKDGv3\",  # Use ETKDG v3 algorithm\n    num_conformers=50,\n    prune_rms_thresh=0.5,  # Remove similar conformers\n    randomSeed=42,\n    useRandomCoords=True\n)\n\njob = generator.make(smiles_job.output[\"structure\"])\n\n# Access generated structures\nstructures = job.output[\"structure\"]  # List of Pymatgen Molecule objects\nfiles = job.output[\"files\"]  # XYZ format files\n</code></pre>"},{"location":"generation/#key-parameters","title":"Key Parameters","text":"<ul> <li>method: Embedding algorithm to use</li> <li>num_conformers: Number of conformers to generate</li> <li>prune_rms_thresh: RMS threshold for pruning similar conformers (in Angstroms)</li> <li>randomSeed: Random seed for reproducibility</li> <li>useRandomCoords: Start from random coordinates</li> <li>maxAttempts: Maximum attempts per conformer generation</li> </ul>"},{"location":"geometry_optimizers/","title":"Geometry Optimizers","text":"<p>Geometry optimizers perform structure relaxation to find local minima on the potential energy surface using various computational methods.</p> <p>options: show_root_heading: true show_source: true show_root_toc_entry: true members: true show_bases: true show_inheritance_diagram: true</p>"},{"location":"geometry_optimizers/#jfchemistry.optimizers","title":"optimizers","text":"<p>Geometry optimization methods for molecular structures.</p> <p>This module provides geometry optimization workflows using various computational methods including neural network potentials, machine learning force fields, and semi-empirical quantum chemistry.</p> Available Optimizers <ul> <li>GeometryOptimization: Base class for geometry optimization</li> <li>ASEOptimizer: Base class for ASE-based optimizers</li> <li>AimNet2Optimizer: Neural network potential optimizer</li> <li>ORBModelOptimizer: Machine learning force field optimizer</li> <li>TBLiteOptimizer: GFN-xTB semi-empirical optimizer</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from jfchemistry.optimizers import TBLiteOptimizer\n&gt;&gt;&gt; from ase.build import molecule\n&gt;&gt;&gt; from pymatgen.core import Molecule\n&gt;&gt;&gt; molecule = Molecule.from_ase_atoms(molecule(\"CCH\"))\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Optimize with GFN2-xTB\n&gt;&gt;&gt; optimizer = TBLiteOptimizer(\n...     method=\"GFN2-xTB\",\n...     fmax=0.01,\n...     steps=1000\n... )\n&gt;&gt;&gt; job = optimizer.make(molecule)\n&gt;&gt;&gt; optimized = job.output[\"structure\"]\n&gt;&gt;&gt; properties = job.output[\"properties\"]\n</code></pre>"},{"location":"geometry_optimizers/#jfchemistry.optimizers-classes","title":"Classes","text":""},{"location":"geometry_optimizers/#jfchemistry.optimizers.ASEOptimizer","title":"ASEOptimizer  <code>dataclass</code>","text":"<pre><code>ASEOptimizer(charge: Optional[int] = None, spin_multiplicity: Optional[int] = None, name: str = 'ASE Optimizer', optimizer: Literal['LBFGS', 'BFGS', 'GPMin', 'MDMin', 'FIRE', 'FIRE2', 'QuasiNewton'] = 'LBFGS', fmax: float = 0.05, steps: int = 250000)\n</code></pre> <p>               Bases: <code>GeometryOptimization</code>, <code>ASECalculator</code></p> <p>Base class for geometry optimization using ASE optimizers.</p> <p>Combines geometry optimization workflows with ASE calculator interfaces. This class provides the framework for optimizing molecular structures using various ASE optimization algorithms (LBFGS, BFGS, FIRE, etc.) and different calculators (neural networks, machine learning, semi-empirical).</p> <p>Subclasses should inherit from both a specific ASECalculator implementation and ASEOptimizer to create complete optimization workflows.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the optimizer (default: \"ASE Optimizer\").</p> <code>optimizer</code> <code>Literal['LBFGS', 'BFGS', 'GPMin', 'MDMin', 'FIRE', 'FIRE2', 'QuasiNewton']</code> <p>ASE optimization algorithm to use: - \"LBFGS\": Limited-memory BFGS (default, recommended) - \"BFGS\": Broyden-Fletcher-Goldfarb-Shanno - \"GPMin\": Conjugate gradient - \"MDMin\": Molecular dynamics minimization - \"FIRE\": Fast Inertial Relaxation Engine - \"FIRE2\": FIRE version 2 - \"QuasiNewton\": Quasi-Newton method</p> <code>fmax</code> <code>float</code> <p>Maximum force convergence criterion in eV/Angstrom (default: 0.05).</p> <code>steps</code> <code>int</code> <p>Maximum number of optimization steps (default: 250000).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from ase.build import molecule\n&gt;&gt;&gt; from pymatgen.core import Molecule\n&gt;&gt;&gt; from jfchemistry.optimizers import ASEOptimizer\n&gt;&gt;&gt; from jfchemistry.calculators import TBLiteCalculator\n&gt;&gt;&gt; molecule = Molecule.from_ase_atoms(molecule(\"C2H6\"))\n&gt;&gt;&gt; # Create custom optimizer by inheriting\n&gt;&gt;&gt; class MyOptimizer(ASEOptimizer, TBLiteCalculator):\n...     pass\n&gt;&gt;&gt;\n&gt;&gt;&gt; opt = MyOptimizer(optimizer=\"LBFGS\", fmax=0.01)\n&gt;&gt;&gt; job = opt.make(molecule)\n</code></pre>"},{"location":"geometry_optimizers/#jfchemistry.optimizers.ASEOptimizer-functions","title":"Functions","text":""},{"location":"geometry_optimizers/#jfchemistry.optimizers.ASEOptimizer.operation","title":"operation","text":"<pre><code>operation(structure: SiteCollection) -&gt; tuple[SiteCollection | list[SiteCollection], Optional[dict[str, Any]]]\n</code></pre> <p>Optimize molecular structure using ASE.</p> <p>Performs geometry optimization by: 1. Converting structure to ASE Atoms 2. Setting up the calculator with charge and spin 3. Running the specified ASE optimizer 4. Converting back to Pymatgen Molecule 5. Extracting properties from the calculation</p> <p>Parameters:</p> Name Type Description Default <code>structure</code> <code>SiteCollection</code> <p>Input molecular structure with 3D coordinates.</p> required <p>Returns:</p> Type Description <code>tuple[SiteCollection | list[SiteCollection], Optional[dict[str, Any]]]</code> <p>Tuple containing: - Optimized Pymatgen Molecule - Dictionary of computed properties from calculator</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from ase.build import molecule\n&gt;&gt;&gt; from pymatgen.core import Molecule\n&gt;&gt;&gt; from jfchemistry.optimizers import TBLiteOptimizer\n&gt;&gt;&gt; ethane = Molecule.from_ase_atoms(molecule(\"C2H6\"))\n&gt;&gt;&gt; opt = TBLiteOptimizer(optimizer=\"LBFGS\", fmax=0.01)\n&gt;&gt;&gt; structures, properties = opt.operation(ethane)\n</code></pre> Source code in <code>jfchemistry/optimizers/ase.py</code> <pre><code>def operation(\n    self, structure: SiteCollection\n) -&gt; tuple[SiteCollection | list[SiteCollection], Optional[dict[str, Any]]]:\n    \"\"\"Optimize molecular structure using ASE.\n\n    Performs geometry optimization by:\n    1. Converting structure to ASE Atoms\n    2. Setting up the calculator with charge and spin\n    3. Running the specified ASE optimizer\n    4. Converting back to Pymatgen Molecule\n    5. Extracting properties from the calculation\n\n    Args:\n        structure: Input molecular structure with 3D coordinates.\n\n    Returns:\n        Tuple containing:\n            - Optimized Pymatgen Molecule\n            - Dictionary of computed properties from calculator\n\n    Examples:\n        &gt;&gt;&gt; from ase.build import molecule # doctest: +SKIP\n        &gt;&gt;&gt; from pymatgen.core import Molecule # doctest: +SKIP\n        &gt;&gt;&gt; from jfchemistry.optimizers import TBLiteOptimizer # doctest: +SKIP\n        &gt;&gt;&gt; ethane = Molecule.from_ase_atoms(molecule(\"C2H6\")) # doctest: +SKIP\n        &gt;&gt;&gt; opt = TBLiteOptimizer(optimizer=\"LBFGS\", fmax=0.01) # doctest: +SKIP\n        &gt;&gt;&gt; structures, properties = opt.operation(ethane) # doctest: +SKIP\n    \"\"\"\n    atoms = structure.to_ase_atoms()\n    charge = int(structure.charge)\n    spin_multiplicity = int(structure.spin_multiplicity)\n    atoms = self.set_calculator(atoms, charge=charge, spin_multiplicity=spin_multiplicity)\n    opt = getattr(ase.optimize, self.optimizer)(atoms, logfile=None)\n    opt.run(self.fmax, self.steps)\n    return Molecule.from_ase_atoms(atoms), self.get_properties(atoms)\n</code></pre>"},{"location":"geometry_optimizers/#jfchemistry.optimizers.AimNet2Optimizer","title":"AimNet2Optimizer  <code>dataclass</code>","text":"<pre><code>AimNet2Optimizer(charge: Optional[int] = None, spin_multiplicity: Optional[int] = None, name: str = 'AimNet2 Optimizer', optimizer: Literal['LBFGS', 'BFGS', 'GPMin', 'MDMin', 'FIRE', 'FIRE2', 'QuasiNewton'] = 'LBFGS', fmax: float = 0.05, steps: int = 250000, model: str = 'aimnet2')\n</code></pre> <p>               Bases: <code>AimNet2Calculator</code>, <code>ASEOptimizer</code></p> <p>Optimize molecular structures using AimNet2 neural network potential.</p> <p>Combines AimNet2's fast neural network energy/force predictions with ASE optimization algorithms for efficient geometry optimization. Ideal for large molecular systems where speed is critical.</p> <p>Inherits all attributes from AimNet2Calculator (model, charge, multiplicity) and ASEOptimizer (optimizer, fmax, steps).</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the optimizer (default: \"AimNet2 Optimizer\").</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from ase.build import molecule\n&gt;&gt;&gt; from pymatgen.core import Molecule\n&gt;&gt;&gt; from jfchemistry.optimizers import AimNet2Optimizer\n&gt;&gt;&gt; molecule = Molecule.from_ase_atoms(molecule(\"CCH\"))\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Fast optimization for screening\n&gt;&gt;&gt; opt_fast = AimNet2Optimizer(\n...     optimizer=\"LBFGS\",\n...     fmax=0.1,  # Looser convergence\n...     steps=500\n... )\n&gt;&gt;&gt; job = opt_fast.make(molecule)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Tight optimization\n&gt;&gt;&gt; opt_tight = AimNet2Optimizer(\n...     optimizer=\"LBFGS\",\n...     fmax=0.01,\n...     charge=-1,\n...     multiplicity=1\n... )\n&gt;&gt;&gt; job = opt_tight.make(molecule)\n&gt;&gt;&gt; optimized = job.output[\"structure\"]\n&gt;&gt;&gt; energy = job.output[\"properties\"][\"Global\"][\"Total Energy [eV]\"]\n</code></pre>"},{"location":"geometry_optimizers/#jfchemistry.optimizers.ORBModelOptimizer","title":"ORBModelOptimizer  <code>dataclass</code>","text":"<pre><code>ORBModelOptimizer(charge: Optional[int] = None, spin_multiplicity: Optional[int] = None, name: str = 'ORB Model Optimizer', optimizer: Literal['LBFGS', 'BFGS', 'GPMin', 'MDMin', 'FIRE', 'FIRE2', 'QuasiNewton'] = 'LBFGS', fmax: float = 0.05, steps: int = 250000, model: Literal['orb-v3-conservative-omol', 'orb-v3-direct-omol'] = 'orb-v3-conservative-omol', device: Literal['cpu', 'cuda'] = 'cpu', precision: Literal['float32-high', 'float32-highest', 'float64'] = 'float32-high', compile: bool = False)\n</code></pre> <p>               Bases: <code>ORBModelCalculator</code>, <code>ASEOptimizer</code></p> <p>Optimize molecular structures using ORB machine learning force field.</p> <p>Combines ORB's graph neural network force field with ASE optimization algorithms for accurate and efficient geometry optimization. Supports GPU acceleration and multiple precision options.</p> <p>Inherits all attributes from ORBModelCalculator (model, device, precision, compile) and ASEOptimizer (optimizer, fmax, steps).</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the optimizer (default: \"ORB Model Optimizer\").</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from jfchemistry.optimizers import ORBModelOptimizer\n&gt;&gt;&gt; from ase.build import molecule\n&gt;&gt;&gt; from pymatgen.core import Molecule\n&gt;&gt;&gt; molecule = Molecule.from_ase_atoms(molecule(\"CCH\"))\n&gt;&gt;&gt; # CPU optimization\n&gt;&gt;&gt; opt_cpu = ORBModelOptimizer(\n...     model=\"orb-v3-conservative-omol\",\n...     device=\"cpu\",\n...     optimizer=\"LBFGS\",\n...     fmax=0.05\n... )\n&gt;&gt;&gt; job = opt_cpu.make(molecule)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # GPU optimization with compilation\n&gt;&gt;&gt; opt_gpu = ORBModelOptimizer(\n...     model=\"orb-v3-conservative-omol\",\n...     device=\"cuda\",\n...     compile=True,\n...     precision=\"float32-highest\",\n...     optimizer=\"LBFGS\",\n...     fmax=0.01\n... )\n&gt;&gt;&gt; job = opt_gpu.make(molecule)\n</code></pre>"},{"location":"geometry_optimizers/#jfchemistry.optimizers.TBLiteOptimizer","title":"TBLiteOptimizer  <code>dataclass</code>","text":"<pre><code>TBLiteOptimizer(charge: Optional[int] = None, spin_multiplicity: Optional[int] = None, name: str = 'TBLite Optimizer', optimizer: Literal['LBFGS', 'BFGS', 'GPMin', 'MDMin', 'FIRE', 'FIRE2', 'QuasiNewton'] = 'LBFGS', fmax: float = 0.05, steps: int = 250000, method: Literal['GFN1-xTB', 'GFN2-xTB', 'IPEA1-xTB'] = 'GFN2-xTB', accuracy: float = 1.0, electronic_temperature: float = 300.0, max_iterations: int = 250, initial_guess: Literal['sad', 'eeq'] = 'sad', mixer_damping: float = 0.4, verbosity: int = 0)\n</code></pre> <p>               Bases: <code>TBLiteCalculator</code>, <code>ASEOptimizer</code></p> <p>Optimize molecular structures using GFN-xTB methods.</p> <p>Combines TBLite's GFN-xTB semi-empirical methods with ASE optimization algorithms for geometry optimization with comprehensive property calculation. Provides an excellent balance between speed and accuracy for organic molecules.</p> <p>The optimizer computes extensive molecular properties including energies, partial charges, bond orders, orbital information, and HOMO-LUMO gaps during optimization.</p> <p>Inherits all attributes from TBLiteCalculator (method, charge, multiplicity, accuracy, electronic_temperature, etc.) and ASEOptimizer (optimizer, fmax, steps).</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the optimizer (default: \"TBLite Optimizer\").</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from ase.build import molecule\n&gt;&gt;&gt; from pymatgen.core import Molecule\n&gt;&gt;&gt; from jfchemistry.optimizers import TBLiteOptimizer\n&gt;&gt;&gt; molecule = Molecule.from_ase_atoms(molecule(\"CCH\"))\n&gt;&gt;&gt; # Standard optimization with GFN2-xTB\n&gt;&gt;&gt; opt = TBLiteOptimizer(\n...     method=\"GFN2-xTB\",\n...     optimizer=\"LBFGS\",\n...     fmax=0.05,\n...     accuracy=1.0\n... )\n&gt;&gt;&gt; job = opt.make(molecule)\n&gt;&gt;&gt; optimized = job.output[\"structure\"]\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Tight optimization with detailed properties\n&gt;&gt;&gt; opt_tight = TBLiteOptimizer(\n...     method=\"GFN2-xTB\",\n...     optimizer=\"LBFGS\",\n...     fmax=0.01,\n...     accuracy=0.1,  # Tighter SCF\n...     max_iterations=500,\n...     charge=-1,\n...     multiplicity=1\n... )\n&gt;&gt;&gt; job = opt_tight.make(molecule)\n&gt;&gt;&gt; props = job.output[\"properties\"]\n&gt;&gt;&gt; gap = props[\"Global\"][\"HOMO-LUMO Gap [eV]\"]\n&gt;&gt;&gt; charges = props[\"Atomic\"][\"Mulliken Partial Charges [e]\"]\n&gt;&gt;&gt; bond_orders = props[\"Bond\"][\"Wiberg Bond Order\"]\n</code></pre>"},{"location":"geometry_optimizers/#example-usage","title":"Example Usage","text":""},{"location":"geometry_optimizers/#optimizing-a-molecule","title":"Optimizing a Molecule","text":"<pre><code>from jfchemistry.optimizers import TBLiteOptimizer\nfrom jfchemistry.inputs import Smiles\n\nsmiles = Smiles()\nsmiles_job = smiles.make(\"CCO\")\nopt = TBLiteOptimizer(\n    method=\"GFN2-xTB\",\n    optimizer=\"LBFGS\",\n    fmax=0.05,\n    accuracy=1.0\n)\njob = opt.make(smiles_job.output[\"structure\"])\noptimized = job.output[\"structure\"]\n</code></pre>"},{"location":"geometry_optimizers/#key-parameters","title":"Key Parameters","text":"<ul> <li>optimizer: Optimizer to use for optimization</li> <li>fmax: Maximum force for optimization</li> <li>accuracy: Accuracy for optimization</li> </ul>"},{"location":"inputs/","title":"Input Types","text":"<p>Input nodes create RDKit molecules from various chemical identifiers and representations. These serve as the entry points for computational chemistry workflows.</p> <p>options: show_root_heading: true show_source: true show_root_toc_entry: true members: true show_bases: true show_inheritance_diagram: true</p>"},{"location":"inputs/#jfchemistry.inputs","title":"inputs","text":"<p>Input types for chemical structure representations.</p> <p>This module provides Maker classes for creating RDKit molecules from various chemical identifiers and representations.</p> Available Input Types <ul> <li>Smiles: Create molecules from SMILES strings</li> <li>PubChemCID: Retrieve molecules from PubChem database by CID</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from jfchemistry.inputs import Smiles, PubChemCID\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Create molecule from SMILES\n&gt;&gt;&gt; smiles_maker = Smiles(add_hydrogens=True, remove_salts=True)\n&gt;&gt;&gt; smiles_job = smiles_maker.make(\"CCO\")\n&gt;&gt;&gt; mol = smiles_job.output[\"structure\"]\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Retrieve molecule from PubChem\n&gt;&gt;&gt; pubchem_maker = PubChemCID()\n&gt;&gt;&gt; pubchem_job = pubchem_maker.make(702)  # Ethanol\n&gt;&gt;&gt; mol = pubchem_job.output[\"structure\"]\n</code></pre>"},{"location":"inputs/#jfchemistry.inputs-classes","title":"Classes","text":""},{"location":"inputs/#jfchemistry.inputs.PubChemCID","title":"PubChemCID  <code>dataclass</code>","text":"<pre><code>PubChemCID(name: str = 'PubChem CID Input', remove_salts: bool = True, add_hydrogens: bool = True)\n</code></pre> <p>               Bases: <code>MoleculeInput</code></p> <p>Retrieve molecules from PubChem database by compound ID.</p> <p>Downloads molecular structures from the PubChem database using the compound identifier (CID). The structure is retrieved in SDF format from PubChem's REST API.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the input method (default: \"PubChem CID Input\").</p> <code>remove_salts</code> <code>bool</code> <p>Inherited from MoleculeInput.</p> <code>add_hydrogens</code> <code>bool</code> <p>Inherited from MoleculeInput.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from jfchemistry.inputs import PubChemCID\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Retrieve ethanol (CID: 702)\n&gt;&gt;&gt; pubchem = PubChemCID()\n&gt;&gt;&gt; job = pubchem.make(702)\n&gt;&gt;&gt; mol = job.output[\"structure\"]\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Retrieve without adding hydrogens\n&gt;&gt;&gt; pubchem_no_h = PubChemCID(add_hydrogens=False)\n&gt;&gt;&gt; job = pubchem_no_h.make(2244)  # Aspirin\n</code></pre>"},{"location":"inputs/#jfchemistry.inputs.PubChemCID-functions","title":"Functions","text":""},{"location":"inputs/#jfchemistry.inputs.PubChemCID.get_structure","title":"get_structure","text":"<pre><code>get_structure(input: int | str) -&gt; rdchem.Mol\n</code></pre> <p>Fetch the structure from PubChem database.</p> <p>Downloads the molecular structure from PubChem using the compound ID and converts it to an RDKit Mol object.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>int | str</code> <p>PubChem compound ID (CID) as integer or string.</p> required <p>Returns:</p> Type Description <code>Mol</code> <p>RDKit Mol object from PubChem SDF data.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from rdkit import Chem\n&gt;&gt;&gt; from jfchemistry import RDMolMolecule\n&gt;&gt;&gt; pubchem = PubChemCID()\n&gt;&gt;&gt; mol = pubchem.get_structure(702)  # Ethanol\n&gt;&gt;&gt; mol.GetNumAtoms()  # Without hydrogens initially\n9\n</code></pre> Source code in <code>jfchemistry/inputs/nodes.py</code> <pre><code>def get_structure(self, input: int | str) -&gt; rdchem.Mol:\n    \"\"\"Fetch the structure from PubChem database.\n\n    Downloads the molecular structure from PubChem using the compound ID\n    and converts it to an RDKit Mol object.\n\n    Args:\n        input: PubChem compound ID (CID) as integer or string.\n\n    Returns:\n        RDKit Mol object from PubChem SDF data.\n\n    Examples:\n        &gt;&gt;&gt; from rdkit import Chem\n        &gt;&gt;&gt; from jfchemistry import RDMolMolecule\n        &gt;&gt;&gt; pubchem = PubChemCID()\n        &gt;&gt;&gt; mol = pubchem.get_structure(702)  # Ethanol\n        &gt;&gt;&gt; mol.GetNumAtoms()  # Without hydrogens initially\n        9\n    \"\"\"\n    import requests\n    from rdkit.Chem import rdmolfiles\n\n    url = f\"https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/cid/{input}/sdf\"\n    resp = requests.get(url)\n    mol = rdmolfiles.MolFromMolBlock(resp.content.decode(\"utf-8\"), removeHs=False)\n    return mol\n</code></pre>"},{"location":"inputs/#jfchemistry.inputs.PubChemCID.make","title":"make","text":"<pre><code>make(input: int) -&gt; Response[dict[str, Any]]\n</code></pre> <p>Create a workflow job to retrieve a molecule from PubChem.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>int</code> <p>PubChem compound ID (CID).</p> required <p>Returns:</p> Type Description <code>Response[dict[str, Any]]</code> <p>Response containing: - structure: RDMolMolecule from PubChem - files: MOL file representation</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from jfchemistry.inputs import PubChemCID\n&gt;&gt;&gt; pubchem = PubChemCID()\n&gt;&gt;&gt; job = pubchem.make(702)\n&gt;&gt;&gt; mol = job.output[\"structure\"]\n&gt;&gt;&gt; mol_file = job.output[\"files\"]\n</code></pre> Source code in <code>jfchemistry/inputs/nodes.py</code> <pre><code>@job(files=\"files\", properties=\"properties\")\ndef make(self, input: int) -&gt; Response[dict[str, Any]]:\n    \"\"\"Create a workflow job to retrieve a molecule from PubChem.\n\n    Args:\n        input: PubChem compound ID (CID).\n\n    Returns:\n        Response containing:\n            - structure: RDMolMolecule from PubChem\n            - files: MOL file representation\n\n    Examples:\n        &gt;&gt;&gt; from jfchemistry.inputs import PubChemCID\n        &gt;&gt;&gt; pubchem = PubChemCID()\n        &gt;&gt;&gt; job = pubchem.make(702)\n        &gt;&gt;&gt; mol = job.output[\"structure\"]\n        &gt;&gt;&gt; mol_file = job.output[\"files\"]\n    \"\"\"\n    return super()._make(input)\n</code></pre>"},{"location":"inputs/#jfchemistry.inputs.Smiles","title":"Smiles  <code>dataclass</code>","text":"<pre><code>Smiles(name: str = 'SMILES Input', remove_salts: bool = True, add_hydrogens: bool = True)\n</code></pre> <p>               Bases: <code>MoleculeInput</code></p> <p>Create molecules from SMILES strings.</p> <p>Parses SMILES (Simplified Molecular Input Line Entry System) strings and converts them to RDKit Mol objects. Supports standard SMILES notation including stereochemistry and aromaticity.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the input method (default: \"SMILES Input\").</p> <code>remove_salts</code> <code>bool</code> <p>Inherited from MoleculeInput.</p> <code>add_hydrogens</code> <code>bool</code> <p>Inherited from MoleculeInput.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from jfchemistry.inputs import Smiles\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Simple molecule\n&gt;&gt;&gt; smiles = Smiles()\n&gt;&gt;&gt; job = smiles.make(\"CCO\")  # Ethanol\n&gt;&gt;&gt; mol = job.output[\"structure\"]\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Aromatic molecule with stereochemistry\n&gt;&gt;&gt; job = smiles.make(\"c1ccc(cc1)C(=O)O\")  # Benzoic acid\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Salt that will be removed\n&gt;&gt;&gt; smiles_clean = Smiles(remove_salts=True)\n&gt;&gt;&gt; job = smiles_clean.make(\"CCO.Cl\")  # Only ethanol kept\n</code></pre>"},{"location":"inputs/#jfchemistry.inputs.Smiles-functions","title":"Functions","text":""},{"location":"inputs/#jfchemistry.inputs.Smiles.get_structure","title":"get_structure","text":"<pre><code>get_structure(input: int | str) -&gt; rdchem.Mol\n</code></pre> <p>Parse SMILES string and convert to RDKit molecule.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>int | str</code> <p>SMILES string representation of the molecule.</p> required <p>Returns:</p> Type Description <code>Mol</code> <p>RDKit Mol object parsed from SMILES.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; smiles = Smiles()\n&gt;&gt;&gt; mol = smiles.get_structure(\"CCO\")\n&gt;&gt;&gt; mol.GetNumAtoms()  # Without hydrogens\n3\n</code></pre> Source code in <code>jfchemistry/inputs/nodes.py</code> <pre><code>def get_structure(self, input: int | str) -&gt; rdchem.Mol:\n    \"\"\"Parse SMILES string and convert to RDKit molecule.\n\n    Args:\n        input: SMILES string representation of the molecule.\n\n    Returns:\n        RDKit Mol object parsed from SMILES.\n\n    Examples:\n        &gt;&gt;&gt; smiles = Smiles()\n        &gt;&gt;&gt; mol = smiles.get_structure(\"CCO\")\n        &gt;&gt;&gt; mol.GetNumAtoms()  # Without hydrogens\n        3\n    \"\"\"\n    return rdmolfiles.MolFromSmiles(input)\n</code></pre>"},{"location":"inputs/#jfchemistry.inputs.Smiles.make","title":"make","text":"<pre><code>make(input: str) -&gt; Response[dict[str, Any]]\n</code></pre> <p>Create a workflow job to generate a molecule from SMILES.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>str</code> <p>SMILES string.</p> required <p>Returns:</p> Type Description <code>Response[dict[str, Any]]</code> <p>Response containing: - structure: RDMolMolecule from SMILES - files: MOL file representation</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from jfchemistry.inputs import Smiles\n&gt;&gt;&gt; smiles = Smiles()\n&gt;&gt;&gt; job = smiles.make(\"c1ccccc1\")  # Benzene\n&gt;&gt;&gt; mol = job.output[\"structure\"]\n&gt;&gt;&gt; mol_file = job.output[\"files\"]\n</code></pre> Source code in <code>jfchemistry/inputs/nodes.py</code> <pre><code>@job(files=\"files\", properties=\"properties\")\ndef make(self, input: str) -&gt; Response[dict[str, Any]]:\n    \"\"\"Create a workflow job to generate a molecule from SMILES.\n\n    Args:\n        input: SMILES string.\n\n    Returns:\n        Response containing:\n            - structure: RDMolMolecule from SMILES\n            - files: MOL file representation\n\n    Examples:\n        &gt;&gt;&gt; from jfchemistry.inputs import Smiles\n        &gt;&gt;&gt; smiles = Smiles()\n        &gt;&gt;&gt; job = smiles.make(\"c1ccccc1\")  # Benzene\n        &gt;&gt;&gt; mol = job.output[\"structure\"]\n        &gt;&gt;&gt; mol_file = job.output[\"files\"]\n    \"\"\"\n    return super()._make(input)\n</code></pre>"},{"location":"inputs/#example-usage","title":"Example Usage","text":""},{"location":"inputs/#creating-molecules-from-smiles","title":"Creating Molecules from SMILES","text":"<pre><code>from jfchemistry.inputs import Smiles\n\n# Basic usage\nsmiles = Smiles()\njob = smiles.make(\"CCO\")  # Ethanol\nmolecule = job.output[\"structure\"]\n\n# With options\nsmiles = Smiles(\n    add_hydrogens=True,  # Add explicit hydrogens\n    remove_salts=True     # Remove salt fragments\n)\n\n# Multiple molecules\nethanol = smiles.make(\"CCO\")\nbenzene = smiles.make(\"c1ccccc1\")\nwater = smiles.make(\"O\")\n</code></pre>"},{"location":"inputs/#retrieving-from-pubchem","title":"Retrieving from PubChem","text":"<pre><code>from jfchemistry.inputs import PubChemCID\n\n# Get molecule by CID\npubchem = PubChemCID()\njob = pubchem.make(702)  # Ethanol CID\n\nmolecule = job.output[\"structure\"]\n\n# Common molecule CIDs:\n# 702 - Ethanol\n# 241 - Benzene\n# 962 - Water\n# 6324 - Glucose\n# 5950 - Aspirin\n</code></pre>"},{"location":"inputs/#building-workflows","title":"Building Workflows","text":"<p>Input nodes are typically the first step in a workflow:</p> <pre><code>from jfchemistry.inputs import Smiles\nfrom jfchemistry.generation import RDKitGeneration\nfrom jfchemistry.optimizers import TBLiteOptimizer\n\n# Create workflow\nsmiles = Smiles(add_hydrogens=True)\ngenerator = RDKitGeneration(num_conformers=10)\noptimizer = TBLiteOptimizer(method=\"GFN2-xTB\")\n\n# Chain jobs\nsmiles_job = smiles.make(\"CC(C)CC(C)C\")\ngen_job = generator.make(smiles_job.output[\"structure\"])\nopt_job = optimizer.make(gen_job.output[\"structure\"])\n\n# Access final results\noptimized_structures = opt_job.output[\"structure\"]\nenergies = opt_job.output[\"properties\"]\n</code></pre>"},{"location":"inputs/#tips","title":"Tips","text":"<ol> <li>Use explicit hydrogens: Enable <code>add_hydrogens=True</code> when you need accurate 3D geometries</li> <li>Clean up structures: Use <code>remove_salts=True</code> to handle molecules with counterions</li> <li>Validate SMILES: Invalid SMILES strings will raise an error - use RDKit's sanitization</li> <li>PubChem CIDs: Search PubChem database online to find CIDs for your molecules of interest</li> </ol>"},{"location":"modification/","title":"Structure Modification","text":"<p>Structure modification methods allow chemical transformations of molecules, including protonation state changes and other structural alterations.</p> <p>options: show_root_heading: true show_source: true show_root_toc_entry: true members: true show_bases: true show_inheritance_diagram: true</p>"},{"location":"modification/#jfchemistry.modification","title":"modification","text":"<p>Structure modification methods.</p> <p>This module provides tools for modifying molecular structures including protonation state changes, atom additions/removals, and other structural transformations.</p> Available Methods <ul> <li>StructureModification: Base class for structure modifications</li> <li>CRESTDeprotonation: CREST-based deprotonation</li> <li>CREST Protonation: CREST-based protonation</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from jfchemistry.modification import CRESTProtonation\n&gt;&gt;&gt; from pymatgen.core import Molecule\n&gt;&gt;&gt; from ase.build import molecule\n&gt;&gt;&gt; ethane = Molecule.from_ase_atoms(molecule(\"C2H6\"))\n&gt;&gt;&gt; # Protonate a molecule\n&gt;&gt;&gt; protonation = CRESTProtonation(ewin=6.0, threads=4)\n&gt;&gt;&gt; job = protonation.make(ethane)\n&gt;&gt;&gt; protonated_structures = job.output[\"structure\"]\n</code></pre>"},{"location":"modification/#jfchemistry.modification-classes","title":"Classes","text":""},{"location":"modification/#jfchemistry.modification.CRESTDeprotonation","title":"CRESTDeprotonation  <code>dataclass</code>","text":"<pre><code>CRESTDeprotonation(name: str = 'CREST Deprotonation', ewin: Optional[float] = None)\n</code></pre> <p>               Bases: <code>StructureModification</code></p> <p>Generate deprotonated structures using CREST.</p> <p>Uses CREST's automated deprotonation workflow to identify acidic sites and generate low-energy deprotonated structures. The method systematically explores different deprotonation sites and optimizes the resulting structures using GFN2-xTB.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the job (default: \"CREST Deprotonation\").</p> <code>ewin</code> <code>Optional[float]</code> <p>Energy window in kcal/mol for selecting deprotonated structures (default: None, uses CREST default). Structures within ewin of the lowest energy structure are retained.</p> References <ul> <li>CREST Documentation: https://crest-lab.github.io/crest-docs/</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from jfchemistry.modification import CRESTDeprotonation\n&gt;&gt;&gt; from pymatgen.core import Molecule\n&gt;&gt;&gt; &gt;&gt;&gt; from ase.build import molecule\n&gt;&gt;&gt; ethane = Molecule.from_ase_atoms(molecule(\"C2H6\"))\n&gt;&gt;&gt; # Deprotonate a ethane\n&gt;&gt;&gt; deprot = CRESTDeprotonation(ewin=6.0)\n&gt;&gt;&gt; job = deprot.make(ethane)\n&gt;&gt;&gt; deprotonated_structures = job.output[\"structure\"]\n&gt;&gt;&gt;\n&gt;&gt;&gt; deprot_default = CRESTDeprotonation()\n&gt;&gt;&gt; job = deprot_default.make(ethane)\n</code></pre>"},{"location":"modification/#jfchemistry.modification.CRESTDeprotonation-functions","title":"Functions","text":""},{"location":"modification/#jfchemistry.modification.CRESTDeprotonation.operation","title":"operation","text":"<pre><code>operation(structure: SiteCollection) -&gt; tuple[SiteCollection | list[SiteCollection], Optional[dict[str, Any]]]\n</code></pre> <p>Generate deprotonated structures using CREST.</p> <p>Runs CREST's deprotonation workflow to identify acidic sites and generate optimized deprotonated structures. The calculation uses GFN2-xTB with Wiberg bond order analysis.</p> <p>Parameters:</p> Name Type Description Default <code>structure</code> <code>SiteCollection</code> <p>Input molecular structure with 3D coordinates. The structure's charge is used for the CREST calculation.</p> required <p>Returns:</p> Type Description <code>tuple[SiteCollection | list[SiteCollection], Optional[dict[str, Any]]]</code> <p>Tuple containing: - List of deprotonated structures sorted by energy - None (no additional properties)</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pymatgen.core import Molecule\n&gt;&gt;&gt; from ase.build import molecule\n&gt;&gt;&gt; ethane = Molecule.from_ase_atoms(molecule(\"C2H6\"))\n&gt;&gt;&gt; deprot = CRESTDeprotonation(ewin=8.0)\n&gt;&gt;&gt; structures, props = deprot.operation(ethane)\n&gt;&gt;&gt; print(f\"Generated {len(structures)} deprotonated structures\")\n</code></pre> Source code in <code>jfchemistry/modification/crest_deprotonation.py</code> <pre><code>def operation(\n    self, structure: SiteCollection\n) -&gt; tuple[SiteCollection | list[SiteCollection], Optional[dict[str, Any]]]:\n    \"\"\"Generate deprotonated structures using CREST.\n\n    Runs CREST's deprotonation workflow to identify acidic sites and\n    generate optimized deprotonated structures. The calculation uses\n    GFN2-xTB with Wiberg bond order analysis.\n\n    Args:\n        structure: Input molecular structure with 3D coordinates. The\n            structure's charge is used for the CREST calculation.\n\n    Returns:\n        Tuple containing:\n            - List of deprotonated structures sorted by energy\n            - None (no additional properties)\n\n    Examples:\n        &gt;&gt;&gt; from pymatgen.core import Molecule # doctest: +SKIP\n        &gt;&gt;&gt; from ase.build import molecule # doctest: +SKIP\n        &gt;&gt;&gt; ethane = Molecule.from_ase_atoms(molecule(\"C2H6\")) # doctest: +SKIP\n        &gt;&gt;&gt; deprot = CRESTDeprotonation(ewin=8.0) # doctest: +SKIP\n        &gt;&gt;&gt; structures, props = deprot.operation(ethane) # doctest: +SKIP\n        &gt;&gt;&gt; print(f\"Generated {len(structures)} deprotonated structures\") # doctest: +SKIP\n    \"\"\"\n    structure.to(\"input.sdf\", fmt=\"sdf\")\n\n    d = {\"calculation\": {\"level\": {\"method\": \"gfn2\", \"rdwbo\": True}}}\n    with open(\"crest.toml\", \"wb\") as f:\n        tomli_w.dump(d, f)\n    commands = [\"crest\", \"input.sdf\", \"--deprotonate\", \"--input\", \"crest.toml\"]\n    if self.ewin is not None:\n        commands.append(f\"--ewin {self.ewin}\")\n    charge = structure.charge\n    commands.append(f\"--chrg {charge} --newversion\")\n    commands.append(\" &gt; log.out\")\n\n    # Save current working directory\n    original_dir = os.getcwd()\n\n    # Create temporary directory and run crest there\n    with tempfile.TemporaryDirectory() as tmp_dir:\n        # Copy input files to temp directory\n        shutil.copy(\"input.sdf\", tmp_dir)\n        shutil.copy(\"crest.toml\", tmp_dir)\n\n        # Change to temp directory\n        os.chdir(tmp_dir)\n\n        # Run crest command\n        subprocess.call(\" \".join(commands), shell=True)\n        # Copy log.out back to original directory\n        if os.path.exists(\"log.out\"):\n            shutil.copy(\"log.out\", original_dir)\n\n        # Copy all crest_conformers.* files back to original directory\n        for file in glob.glob(\"deprotonated.xyz\"):\n            shutil.copy(file, original_dir)\n\n        # Change back to original directory\n        os.chdir(original_dir)\n\n    structures = XYZ.from_file(\"deprotonated.xyz\").all_molecules\n    structures = cast(\"list[SiteCollection]\", structures)\n    return structures, None\n</code></pre>"},{"location":"modification/#jfchemistry.modification.CRESTProtonation","title":"CRESTProtonation  <code>dataclass</code>","text":"<pre><code>CRESTProtonation(name: str = 'CREST Protonation', runtype: Literal['protonate'] = 'protonate', ion: Optional[str] = None, ion_charge: int = 1, ewin: Optional[float] = None, ffopt: bool = True, freezeopt: Optional[str] = None, finalopt: bool = True, threads: int = 1, solvation: Optional[Union[tuple[Literal['alpb'], Literal['acetone', 'acetonitrile', 'aniline', 'benzaldehyde', 'benzene', 'ch2cl2', 'chcl3', 'cs2', 'dioxane', 'dmf', 'dmso', 'ether', 'ethylacetate', 'furane', 'hexandecane', 'hexane', 'methanol', 'nitromethane', 'octanol', 'woctanol', 'phenol', 'toluene', 'thf', 'water']], tuple[Literal['gbsa'], Literal['acetone', 'acetonitrile', 'benzene', 'CH2Cl2', 'CHCl3', 'CS2', 'DMF', 'DMSO', 'ether', 'H2O', 'methanol', 'n-hexane', 'THF', 'toluene']]]] = None)\n</code></pre> <p>               Bases: <code>StructureModification</code></p> <p>Generate protonated structures using CREST.</p> <p>Uses CREST's automated protonation workflow to identify basic sites and generate low-energy protonated structures. The method systematically explores different protonation sites and optimizes the resulting structures.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the job (default: \"CREST Protonation\").</p> <code>runtype</code> <code>Literal['protonate']</code> <p>Workflow type (default: \"protonate\").</p> <code>ion</code> <code>Optional[str]</code> <p>Ion to add for protonation (default: None, uses H+).</p> <code>ion_charge</code> <code>int</code> <p>Charge of the ion (default: 1).</p> <code>ewin</code> <code>Optional[float]</code> <p>Energy window in kcal/mol for selecting protonated structures (default: None, uses CREST default).</p> <code>ffopt</code> <code>bool</code> <p>Perform force field pre-optimization (default: True).</p> <code>freezeopt</code> <code>Optional[str]</code> <p>Freeze constraint string for optimization (default: None).</p> <code>finalopt</code> <code>bool</code> <p>Perform final optimization (default: True).</p> <code>threads</code> <code>int</code> <p>Number of parallel threads (default: 1).</p> <code>solvation</code> <code>Optional[Union[tuple[Literal['alpb'], Literal['acetone', 'acetonitrile', 'aniline', 'benzaldehyde', 'benzene', 'ch2cl2', 'chcl3', 'cs2', 'dioxane', 'dmf', 'dmso', 'ether', 'ethylacetate', 'furane', 'hexandecane', 'hexane', 'methanol', 'nitromethane', 'octanol', 'woctanol', 'phenol', 'toluene', 'thf', 'water']], tuple[Literal['gbsa'], Literal['acetone', 'acetonitrile', 'benzene', 'CH2Cl2', 'CHCl3', 'CS2', 'DMF', 'DMSO', 'ether', 'H2O', 'methanol', 'n-hexane', 'THF', 'toluene']]]]</code> <p>Implicit solvation model as (model, solvent) tuple. Either (\"alpb\", \"water\") or (\"gbsa\", \"water\"). Only one can be set (default: None).</p> References <ul> <li>CREST Documentation: https://crest-lab.github.io/crest-docs/</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from jfchemistry.modification import CRESTProtonation\n&gt;&gt;&gt; from pymatgen.core import Molecule\n&gt;&gt;&gt; from ase.build import molecule\n&gt;&gt;&gt; molecule = Molecule.from_ase_atoms(molecule(\"CCH\"))\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Protonate an amine\n&gt;&gt;&gt; prot = CRESTProtonation(ewin=6.0, threads=4)\n&gt;&gt;&gt; job = prot.make(molecule)\n&gt;&gt;&gt; protonated_structures = job.output[\"structure\"]\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Protonate with custom settings\n&gt;&gt;&gt; prot_custom = CRESTProtonation(\n...     ewin=8.0,\n...     ffopt=True,\n...     finalopt=True,\n...     threads=8\n... )\n&gt;&gt;&gt; job = prot_custom.make(molecule)\n&gt;&gt;&gt; protonated_structures = job.output[\"structure\"]\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Protonate with implicit solvation (ALPB)\n&gt;&gt;&gt; prot_solv = CRESTProtonation(\n...     ewin=6.0,\n...     solvation=(\"alpb\", \"water\")  # ALPB with water\n... )\n&gt;&gt;&gt; job = prot_solv.make(molecule)\n&gt;&gt;&gt; protonated_structures = job.output[\"structure\"]\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Protonate with GBSA solvation\n&gt;&gt;&gt; prot_gbsa = CRESTProtonation(\n...     ewin=6.0,\n...     solvation=(\"gbsa\", \"DMSO\")  # GBSA with DMSO\n... )\n&gt;&gt;&gt; job = prot_gbsa.make(molecule)\n&gt;&gt;&gt; protonated_structures = job.output[\"structure\"]\n</code></pre>"},{"location":"modification/#jfchemistry.modification.CRESTProtonation-functions","title":"Functions","text":""},{"location":"modification/#jfchemistry.modification.CRESTProtonation.make_dict","title":"make_dict","text":"<pre><code>make_dict()\n</code></pre> <p>Create parameter dictionary for CREST configuration.</p> <p>Extracts relevant protonation parameters and packages them for the CREST TOML configuration file.</p> <p>Returns:</p> Type Description <p>Dictionary of non-None protonation parameters.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; prot = CRESTProtonation(ewin=6.0, ffopt=True)\n&gt;&gt;&gt; params = prot.make_dict()\n&gt;&gt;&gt; print(params)\n{'ewin': 6.0, 'ffopt': True, 'finalopt': True}\n</code></pre> Source code in <code>jfchemistry/modification/crest_protonation.py</code> <pre><code>def make_dict(self):\n    \"\"\"Create parameter dictionary for CREST configuration.\n\n    Extracts relevant protonation parameters and packages them for\n    the CREST TOML configuration file.\n\n    Returns:\n        Dictionary of non-None protonation parameters.\n\n    Examples:\n        &gt;&gt;&gt; prot = CRESTProtonation(ewin=6.0, ffopt=True)\n        &gt;&gt;&gt; params = prot.make_dict()\n        &gt;&gt;&gt; print(params)\n        {'ewin': 6.0, 'ffopt': True, 'finalopt': True}\n    \"\"\"\n    keys = [\"ion\", \"ewin\", \"ffopt\", \"freezeopt\", \"finalopt\"]\n    d = {}\n    for k, v in vars(self).items():\n        if v is None or k not in keys:\n            continue\n        d[k] = v\n    return d\n</code></pre>"},{"location":"modification/#jfchemistry.modification.CRESTProtonation.operation","title":"operation","text":"<pre><code>operation(structure: SiteCollection) -&gt; tuple[SiteCollection | list[SiteCollection], Optional[dict[str, Any]]]\n</code></pre> <p>Generate protonated structures using CREST.</p> <p>Runs CREST's protonation workflow to identify basic sites and generate optimized protonated structures.</p> <p>Parameters:</p> Name Type Description Default <code>structure</code> <code>SiteCollection</code> <p>Input molecular structure with 3D coordinates. The structure's charge is used for the CREST calculation.</p> required <p>Returns:</p> Type Description <code>tuple[SiteCollection | list[SiteCollection], Optional[dict[str, Any]]]</code> <p>Tuple containing: - List of protonated structures sorted by energy - None (no additional properties)</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pymatgen.core import Molecule\n&gt;&gt;&gt; from ase.build import molecule\n&gt;&gt;&gt; molecule = Molecule.from_ase_atoms(molecule(\"C2H6\"))\n&gt;&gt;&gt; prot = CRESTProtonation(ewin=6.0, threads=4)\n&gt;&gt;&gt; structures, properties = prot.operation(molecule)\n</code></pre> Source code in <code>jfchemistry/modification/crest_protonation.py</code> <pre><code>def operation(\n    self, structure: SiteCollection\n) -&gt; tuple[SiteCollection | list[SiteCollection], Optional[dict[str, Any]]]:\n    \"\"\"Generate protonated structures using CREST.\n\n    Runs CREST's protonation workflow to identify basic sites and\n    generate optimized protonated structures.\n\n    Args:\n        structure: Input molecular structure with 3D coordinates. The\n            structure's charge is used for the CREST calculation.\n\n    Returns:\n        Tuple containing:\n            - List of protonated structures sorted by energy\n            - None (no additional properties)\n\n    Examples:\n        &gt;&gt;&gt; from pymatgen.core import Molecule # doctest: +SKIP\n        &gt;&gt;&gt; from ase.build import molecule # doctest: +SKIP\n        &gt;&gt;&gt; molecule = Molecule.from_ase_atoms(molecule(\"C2H6\")) # doctest: +SKIP\n        &gt;&gt;&gt; prot = CRESTProtonation(ewin=6.0, threads=4) # doctest: +SKIP\n        &gt;&gt;&gt; structures, properties = prot.operation(molecule) # doctest: +SKIP\n    \"\"\"\n    structure.to(\"input.xyz\", fmt=\"xyz\")\n\n    # Write the input file\n    self.inputfile = \"input.xyz\"\n    d = {\"threads\": self.threads, \"runtype\": self.runtype, \"input\": \"input.xyz\"}\n    d[\"protonation\"] = self.make_dict()\n    with open(\"crest.toml\", \"wb\") as f:\n        tomli_w.dump(d, f)\n\n    charge = structure.charge\n\n    # Save current working directory\n    original_dir = os.getcwd()\n\n    commands = [\"crest\", \"--input\", \"crest.toml\", \"--chrg\", str(charge), \"--newversion\"]\n\n    if self.solvation is not None:\n        solvation_model, solvent = self.solvation\n        commands.append(f\"--{solvation_model}\")\n        commands.append(solvent)\n\n    # Create temporary directory and run crest there\n    with tempfile.TemporaryDirectory() as tmp_dir:\n        # Copy input files to temp directory\n        shutil.copy(\"input.xyz\", tmp_dir)\n        shutil.copy(\"crest.toml\", tmp_dir)\n\n        # Change to temp directory\n        os.chdir(tmp_dir)\n\n        # Run crest command\n        subprocess.call(\n            f\"{' '.join(commands)} &gt; log.out\",\n            shell=True,\n        )\n        # Copy log.out back to original directory\n        if os.path.exists(\"log.out\"):\n            shutil.copy(\"log.out\", original_dir)\n\n        # Copy all crest_conformers.* files back to original directory\n        for file in glob.glob(\"protonated.xyz\"):\n            shutil.copy(file, original_dir)\n\n        # Change back to original directory\n        os.chdir(original_dir)\n\n    structures = XYZ.from_file(\"protonated.xyz\").all_molecules\n    structures = cast(\"list[SiteCollection]\", structures)\n    return structures, None\n</code></pre>"},{"location":"modification/#jfchemistry.modification.CRESTTautomers","title":"CRESTTautomers  <code>dataclass</code>","text":"<pre><code>CRESTTautomers(name: str = 'CREST Tautomers', runtype: Literal['tautomerize'] = 'tautomerize', ewin: Optional[float] = None, ffopt: bool = True, freezeopt: Optional[str] = None, finalopt: bool = True, threads: int = 1)\n</code></pre> <p>               Bases: <code>StructureModification</code></p> <p>Generate tautomers using CREST.</p> <p>Uses CREST's automated tautomerization workflow to identify basic sites and generate low-energy tautomers. The method systematically explores different tautomer sites and optimizes the resulting structures.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the job (default: \"CREST Tautomers\").</p> <code>runtype</code> <code>Literal['tautomerize']</code> <p>Workflow type (default: \"tautomerize\").</p> <code>ewin</code> <code>Optional[float]</code> <p>Energy window in kcal/mol for selecting tautomers (default: None, uses CREST default).</p> <code>ffopt</code> <code>bool</code> <p>Perform force field pre-optimization (default: True).</p> <code>freezeopt</code> <code>Optional[str]</code> <p>Freeze constraint string for optimization (default: None).</p> <code>finalopt</code> <code>bool</code> <p>Perform final optimization (default: True).</p> <code>threads</code> <code>int</code> <p>Number of parallel threads (default: 1).</p> References <ul> <li>CREST Documentation: https://crest-lab.github.io/crest-docs/</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from jfchemistry.modification import CRESTTautomers\n&gt;&gt;&gt; from pymatgen.core import Molecule\n&gt;&gt;&gt; from ase.build import molecule\n&gt;&gt;&gt; molecule = Molecule.from_ase_atoms(molecule(\"CCH\"))\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Protonate an amine\n&gt;&gt;&gt; prot = CRESTTautomers(ewin=6.0, threads=4)\n&gt;&gt;&gt; job = prot.make(molecule)\n&gt;&gt;&gt; protonated_structures = job.output[\"structure\"]\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Protonate with custom settings\n&gt;&gt;&gt; prot_custom = CRESTTautomers(\n...     ewin=8.0,\n...     ffopt=True,\n...     finalopt=True,\n...     threads=8\n... )\n&gt;&gt;&gt; job = prot_custom.make(molecule)\n&gt;&gt;&gt; protonated_structures = job.output[\"structure\"]\n</code></pre>"},{"location":"modification/#jfchemistry.modification.CRESTTautomers-functions","title":"Functions","text":""},{"location":"modification/#jfchemistry.modification.CRESTTautomers.make_dict","title":"make_dict","text":"<pre><code>make_dict()\n</code></pre> <p>Create parameter dictionary for CREST configuration.</p> <p>Extracts relevant protonation parameters and packages them for the CREST TOML configuration file.</p> <p>Returns:</p> Type Description <p>Dictionary of non-None protonation parameters.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from jfchemistry.modification import CRESTTautomers\n&gt;&gt;&gt; prot = CRESTTautomers(ewin=6.0, ffopt=True)\n&gt;&gt;&gt; params = prot.make_dict()\n&gt;&gt;&gt; print(params)\n{'ewin': 6.0, 'ffopt': True, 'finalopt': True}\n</code></pre> Source code in <code>jfchemistry/modification/crest_tautomers.py</code> <pre><code>def make_dict(self):\n    \"\"\"Create parameter dictionary for CREST configuration.\n\n    Extracts relevant protonation parameters and packages them for\n    the CREST TOML configuration file.\n\n    Returns:\n        Dictionary of non-None protonation parameters.\n\n    Examples:\n        &gt;&gt;&gt; from jfchemistry.modification import CRESTTautomers\n        &gt;&gt;&gt; prot = CRESTTautomers(ewin=6.0, ffopt=True)\n        &gt;&gt;&gt; params = prot.make_dict()\n        &gt;&gt;&gt; print(params)\n        {'ewin': 6.0, 'ffopt': True, 'finalopt': True}\n    \"\"\"\n    keys = [\"ion\", \"ewin\", \"ffopt\", \"freezeopt\", \"finalopt\"]\n    d = {}\n    for k, v in vars(self).items():\n        if v is None or k not in keys:\n            continue\n        d[k] = v\n    return d\n</code></pre>"},{"location":"modification/#jfchemistry.modification.CRESTTautomers.operation","title":"operation","text":"<pre><code>operation(structure: SiteCollection) -&gt; tuple[SiteCollection | list[SiteCollection], Optional[dict[str, Any]]]\n</code></pre> <p>Generate protonated structures using CREST.</p> <p>Runs CREST's protonation workflow to identify basic sites and generate optimized protonated structures.</p> <p>Parameters:</p> Name Type Description Default <code>structure</code> <code>SiteCollection</code> <p>Input molecular structure with 3D coordinates. The structure's charge is used for the CREST calculation.</p> required <p>Returns:</p> Type Description <code>tuple[SiteCollection | list[SiteCollection], Optional[dict[str, Any]]]</code> <p>Tuple containing: - List of protonated structures sorted by energy - None (no additional properties)</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pymatgen.core import Molecule\n&gt;&gt;&gt; from ase.build import molecule\n&gt;&gt;&gt; from jfchemistry.modification import CRESTTautomers\n&gt;&gt;&gt; molecule = Molecule.from_ase_atoms(molecule(\"C2H6\"))\n&gt;&gt;&gt; prot = CRESTTautomers(ewin=6.0, threads=4)\n&gt;&gt;&gt; structures, properties = prot.operation(molecule)\n</code></pre> Source code in <code>jfchemistry/modification/crest_tautomers.py</code> <pre><code>def operation(\n    self, structure: SiteCollection\n) -&gt; tuple[SiteCollection | list[SiteCollection], Optional[dict[str, Any]]]:\n    \"\"\"Generate protonated structures using CREST.\n\n    Runs CREST's protonation workflow to identify basic sites and\n    generate optimized protonated structures.\n\n    Args:\n        structure: Input molecular structure with 3D coordinates. The\n            structure's charge is used for the CREST calculation.\n\n    Returns:\n        Tuple containing:\n            - List of protonated structures sorted by energy\n            - None (no additional properties)\n\n    Examples:\n        &gt;&gt;&gt; from pymatgen.core import Molecule # doctest: +SKIP\n        &gt;&gt;&gt; from ase.build import molecule # doctest: +SKIP\n        &gt;&gt;&gt; from jfchemistry.modification import CRESTTautomers # doctest: +SKIP\n        &gt;&gt;&gt; molecule = Molecule.from_ase_atoms(molecule(\"C2H6\")) # doctest: +SKIP\n        &gt;&gt;&gt; prot = CRESTTautomers(ewin=6.0, threads=4) # doctest: +SKIP\n        &gt;&gt;&gt; structures, properties = prot.operation(molecule) # doctest: +SKIP\n    \"\"\"\n    structure.to(\"input.xyz\", fmt=\"xyz\")\n\n    # Write the input file\n    self.inputfile = \"input.xyz\"\n    charge = structure.charge\n\n    # Save current working directory\n    original_dir = os.getcwd()\n\n    # Create temporary directory and run crest there\n    with tempfile.TemporaryDirectory() as tmp_dir:\n        # Copy input files to temp directory\n        shutil.copy(\"input.xyz\", tmp_dir)\n\n        # Change to temp directory\n        os.chdir(tmp_dir)\n\n        # Run crest command\n        subprocess.call(\n            f\"crest input.xyz --chrg {charge} --tautomerize --newversion &gt; log.out\",\n            shell=True,\n        )\n        # Copy log.out back to original directory\n        if os.path.exists(\"log.out\"):\n            shutil.copy(\"log.out\", original_dir)\n\n        # Copy all crest_conformers.* files back to original directory\n        for file in glob.glob(\"tautomers.xyz\"):\n            shutil.copy(file, original_dir)\n\n        # Change back to original directory\n        os.chdir(original_dir)\n\n    structures = XYZ.from_file(\"tautomers.xyz\").all_molecules\n    structures = cast(\"list[SiteCollection]\", structures)\n    return structures, None\n</code></pre>"},{"location":"modification/#jfchemistry.modification.StructureModification","title":"StructureModification  <code>dataclass</code>","text":"<pre><code>StructureModification(name: str = 'Structure Modification')\n</code></pre> <p>               Bases: <code>SingleStructureMaker</code></p> <p>Base class for structure modification methods.</p> <p>This abstract class defines the interface for structure modification implementations. Subclasses should implement the operation() method to perform specific modifications such as protonation, deprotonation, atom substitutions, or other structural transformations.</p> <p>Structure modifications typically generate multiple output structures representing different possible modification sites or states.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Descriptive name for the modification method.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Subclass implementation\n&gt;&gt;&gt; from ase.build import molecule\n&gt;&gt;&gt; from pymatgen.core import Molecule\n&gt;&gt;&gt; ethane = Molecule.from_ase_atoms(molecule(\"C2H6\"))\n&gt;&gt;&gt; class MyModification(StructureModification):\n...     def operation(self, structure):\n...         # Perform modification\n...         modified_structures = modify(structure)\n...         properties = {\"num_variants\": len(modified_structures)}\n...         return modified_structures, properties\n&gt;&gt;&gt;\n&gt;&gt;&gt; mod = MyModification()\n&gt;&gt;&gt; job = mod.make(ethane)\n&gt;&gt;&gt; modified = job.output[\"structure\"]\n</code></pre>"},{"location":"modification/#jfchemistry.modification.StructureModification-functions","title":"Functions","text":""},{"location":"modification/#jfchemistry.modification.StructureModification.operation","title":"operation","text":"<pre><code>operation(structure: SiteCollection) -&gt; tuple[SiteCollection | list[SiteCollection], Optional[dict[str, Any]]]\n</code></pre> <p>Modify the input structure.</p> <p>This method must be implemented by subclasses to perform the specific structural modification.</p> <p>Parameters:</p> Name Type Description Default <code>structure</code> <code>SiteCollection</code> <p>Input molecular structure with 3D coordinates.</p> required <p>Returns:</p> Type Description <code>tuple[SiteCollection | list[SiteCollection], Optional[dict[str, Any]]]</code> <p>Tuple containing: - Modified structure(s) (single or list of SiteCollections) - Dictionary of properties from modification (or None)</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>This method must be implemented by subclasses.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # In a subclass\n&gt;&gt;&gt; def operation(self, structure):\n...     modified = []\n...     for site in get_modification_sites(structure):\n...         mod_struct = apply_modification(structure, site)\n...         modified.append(mod_struct)\n...     return modified, {\"num_sites\": len(modified)}\n</code></pre> Source code in <code>jfchemistry/modification/base.py</code> <pre><code>def operation(\n    self, structure: SiteCollection\n) -&gt; tuple[SiteCollection | list[SiteCollection], Optional[dict[str, Any]]]:\n    \"\"\"Modify the input structure.\n\n    This method must be implemented by subclasses to perform the specific\n    structural modification.\n\n    Args:\n        structure: Input molecular structure with 3D coordinates.\n\n    Returns:\n        Tuple containing:\n            - Modified structure(s) (single or list of SiteCollections)\n            - Dictionary of properties from modification (or None)\n\n    Raises:\n        NotImplementedError: This method must be implemented by subclasses.\n\n    Examples:\n        &gt;&gt;&gt; # In a subclass\n        &gt;&gt;&gt; def operation(self, structure):\n        ...     modified = []\n        ...     for site in get_modification_sites(structure):\n        ...         mod_struct = apply_modification(structure, site)\n        ...         modified.append(mod_struct)\n        ...     return modified, {\"num_sites\": len(modified)}\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"modification/#example-usage","title":"Example Usage","text":""},{"location":"modification/#protonation","title":"Protonation","text":"<pre><code>from jfchemistry.modification import CRESTProtonation\nfrom jfchemistry.inputs import Smiles\nfrom jfchemistry.generation import RDKitGeneration\n\n# Create molecule\nsmiles = Smiles()\nsmiles_job = smiles.make(\"CCO\")  # Ethanol\n\n# Generate 3D structure\ngen = RDKitGeneration(num_conformers=1)\ngen_job = gen.make(smiles_job.output[\"structure\"])\n\n# Protonate the molecule\nprotonation = CRESTProtonation(\n    ewin=6.0,\n    calculation_energy_method=\"gfn2\",\n    threads=4\n)\n\njob = protonation.make(gen_job.output[\"structure\"])\n\n# Access protonated structures\nprotonated = job.output[\"structure\"]  # List of protonated conformers\nproperties = job.output[\"properties\"]\n</code></pre>"},{"location":"modification/#deprotonation","title":"Deprotonation","text":"<pre><code>from jfchemistry.modification import CRESTDeprotonation\n\n# Deprotonate a molecule\ndeprotonation = CRESTDeprotonation(\n    ewin=6.0,\n    calculation_energy_method=\"gfn2\",\n    threads=4\n)\n\njob = deprotonation.make(gen_job.output[\"structure\"])\n\n# Access deprotonated structures\ndeprotonated = job.output[\"structure\"]\nproperties = job.output[\"properties\"]\n</code></pre>"},{"location":"modification/#key-parameters","title":"Key Parameters","text":"<ul> <li>ewin: Energy window in kcal/mol for selecting structures</li> <li>calculation_energy_method: Method for energy evaluation (e.g., \"gfn2\", \"gfnff\")</li> <li>threads: Number of parallel threads to use</li> </ul>"},{"location":"modification/#use-cases","title":"Use Cases","text":"<ul> <li>pH-dependent chemistry: Model molecules at different pH values</li> <li>Ionizable groups: Identify favorable ionization states</li> <li>Reaction mechanisms: Explore proton transfer pathways</li> <li>pKa predictions: Generate structures for pKa calculations</li> </ul>"},{"location":"user_guide/","title":"User Guide","text":"<p>This guide provides comprehensive examples of using JFChemistry to build computational chemistry workflows.</p>"},{"location":"user_guide/#basic-concepts","title":"Basic Concepts","text":"<p>JFChemistry is built on jobflow, which enables creating complex, parallelizable workflows. The package is organized around two main base classes:</p> <ul> <li>SingleMoleculeMaker: For operations on molecules without 3D coordinates (RDKit molecules)</li> <li>SingleStructureMaker: For operations on structures with 3D coordinates (Pymatgen structures)</li> </ul> <p>All workflow components in JFChemistry inherit from these base classes and follow a consistent interface.</p>"},{"location":"user_guide/#installation","title":"Installation","text":"<p>Install using Pixi (recommended):</p> <pre><code>git clone https://github.com/cfarm6/jfchemistry.git\ncd jfchemistry\npixi install\n</code></pre> <p>For specific features:</p> <pre><code># For AimNet2 neural network potentials\npixi install -e aimnet2\n\n# For ORB machine learning models\npixi install -e orb\n\n# For development\npixi install -e dev\n</code></pre>"},{"location":"user_guide/#workflow-examples","title":"Workflow Examples","text":""},{"location":"user_guide/#example-1-simple-geometry-optimization","title":"Example 1: Simple Geometry Optimization","text":"<p>The simplest workflow: create a molecule from SMILES and optimize its geometry.</p> <pre><code>from jfchemistry.inputs import Smiles\nfrom jfchemistry.generation import RDKitGeneration\nfrom jfchemistry.optimizers import TBLiteOptimizer\n\n# Create molecule from SMILES\nsmiles_maker = Smiles(add_hydrogens=True)\nsmiles_job = smiles_maker.make(\"CCO\")  # Ethanol\n\n# Generate 3D structure\ngenerator = RDKitGeneration(num_conformers=1, method=\"ETKDGv3\")\ngen_job = generator.make(smiles_job.output[\"structure\"])\n\n# Optimize with GFN2-xTB\noptimizer = TBLiteOptimizer(method=\"GFN2-xTB\", fmax=0.01, steps=1000)\nopt_job = optimizer.make(gen_job.output[\"structure\"])\n\n# Access results\noptimized_structure = opt_job.output[\"structure\"]\nenergy = opt_job.output[\"properties\"][\"Global\"][\"Total Energy [Eh]\"]\nprint(f\"Optimized energy: {energy} Eh\")\n</code></pre>"},{"location":"user_guide/#example-2-conformer-search-workflow","title":"Example 2: Conformer Search Workflow","text":"<p>Generate and optimize multiple conformers to find the global minimum.</p> <pre><code>from jfchemistry.inputs import Smiles\nfrom jfchemistry.generation import RDKitGeneration\nfrom jfchemistry.conformers import CRESTConformers\nfrom jfchemistry.optimizers import TBLiteOptimizer\n\n# Create molecule\nsmiles = Smiles(add_hydrogens=True)\nmol_job = smiles.make(\"CC(C)C(C)C\")  # Branched alkane\n\n# Generate initial 3D structure\ngen = RDKitGeneration(num_conformers=1)\ngen_job = gen.make(mol_job.output[\"structure\"])\n\n# Search conformational space with CREST\nconformer_search = CRESTConformers(\n    runtype=\"imtd-gc\",\n    ewin=6.0,  # 6 kcal/mol energy window\n    calculation_energy_method=\"gfnff\",\n    calculation_dynamics_method=\"gfnff\",\n    threads=4\n)\ncrest_job = conformer_search.make(gen_job.output[\"structure\"])\n\n# Refine conformers with higher-level method\noptimizer = TBLiteOptimizer(method=\"GFN2-xTB\", fmax=0.005)\nopt_job = optimizer.make(crest_job.output[\"structure\"])\n\n# Results\nconformers = opt_job.output[\"structure\"]  # List of optimized conformers\nenergies = [p[\"Global\"][\"Total Energy [Eh]\"]\n            for p in opt_job.output[\"properties\"]]\n\nprint(f\"Found {len(conformers)} unique conformers\")\nprint(f\"Energy range: {max(energies) - min(energies):.4f} Eh\")\n</code></pre>"},{"location":"user_guide/#example-3-high-throughput-screening","title":"Example 3: High-Throughput Screening","text":"<p>Process multiple molecules in parallel using jobflow.</p> <pre><code>from jfchemistry.inputs import Smiles\nfrom jfchemistry.generation import RDKitGeneration\nfrom jfchemistry.optimizers import TBLiteOptimizer\nfrom jobflow import Flow\n\n# Define molecules to screen\nmolecules = [\n    \"CCO\",           # Ethanol\n    \"CC(C)O\",        # Isopropanol\n    \"CCCO\",          # 1-Propanol\n    \"CC(C)(C)O\",     # tert-Butanol\n]\n\n# Create workflow components\nsmiles = Smiles(add_hydrogens=True)\ngenerator = RDKitGeneration(num_conformers=10)\noptimizer = TBLiteOptimizer(method=\"GFN2-xTB\")\n\n# Build jobs for all molecules\nall_jobs = []\nfor mol_smiles in molecules:\n    smiles_job = smiles.make(mol_smiles)\n    gen_job = generator.make(smiles_job.output[\"structure\"])\n    opt_job = optimizer.make(gen_job.output[\"structure\"])\n    all_jobs.append(opt_job)\n\n# Create and run flow\nflow = Flow(all_jobs)\n# flow.run()  # Uncomment to run with jobflow\n</code></pre>"},{"location":"user_guide/#example-4-using-pubchem-database","title":"Example 4: Using PubChem Database","text":"<p>Retrieve molecules from PubChem and process them.</p> <pre><code>from jfchemistry.inputs import PubChemCID\nfrom jfchemistry.generation import RDKitGeneration\nfrom jfchemistry.optimizers import AimNet2Optimizer\n\n# Get molecule from PubChem\npubchem = PubChemCID()\nmol_job = pubchem.make(5950)  # Aspirin CID\n\n# Generate 3D conformers\ngen = RDKitGeneration(num_conformers=20, prune_rms_thresh=0.5)\ngen_job = gen.make(mol_job.output[\"structure\"])\n\n# Optimize with AimNet2 (fast neural network potential)\noptimizer = AimNet2Optimizer(fmax=0.01)\nopt_job = optimizer.make(gen_job.output[\"structure\"])\n\n# Results include charges from AimNet2\nstructures = opt_job.output[\"structure\"]\nproperties = opt_job.output[\"properties\"]\n</code></pre>"},{"location":"user_guide/#example-5-protonation-state-exploration","title":"Example 5: Protonation State Exploration","text":"<p>Explore different protonation states of a molecule.</p> <pre><code>from jfchemistry.inputs import Smiles\nfrom jfchemistry.generation import RDKitGeneration\nfrom jfchemistry.modification import CRESTProtonation, CRESTDeprotonation\nfrom jfchemistry.optimizers import TBLiteOptimizer\n\n# Create molecule (acetic acid)\nsmiles = Smiles(add_hydrogens=True)\nmol_job = smiles.make(\"CC(=O)O\")\n\n# Generate 3D structure\ngen = RDKitGeneration(num_conformers=1)\ngen_job = gen.make(mol_job.output[\"structure\"])\n\n# Deprotonate (create acetate anion)\ndeprot = CRESTDeprotonation(\n    ewin=6.0,\n    calculation_energy_method=\"gfn2\",\n    threads=4\n)\ndeprot_job = deprot.make(gen_job.output[\"structure\"])\n\n# Optimize deprotonated structures\noptimizer = TBLiteOptimizer(method=\"GFN2-xTB\", charge=-1)\nopt_job = optimizer.make(deprot_job.output[\"structure\"])\n\n# Compare energies\ndeprotonated_structures = opt_job.output[\"structure\"]\n</code></pre>"},{"location":"user_guide/#example-6-custom-calculator-usage","title":"Example 6: Custom Calculator Usage","text":"<p>Use calculators directly for single-point energy calculations.</p> <pre><code>from jfchemistry.calculators import TBLiteCalculator\nfrom jfchemistry.inputs import Smiles\nfrom jfchemistry.generation import RDKitGeneration\n\n# Generate structure\nsmiles = Smiles()\ngen = RDKitGeneration(num_conformers=1)\nsmiles_job = smiles.make(\"C\")\ngen_job = gen.make(smiles_job.output[\"structure\"])\n\n# Get structure and convert to ASE\nstructure = gen_job.output[\"structure\"]\natoms = structure.to_ase_atoms()\n\n# Setup calculator\ncalc = TBLiteCalculator(method=\"GFN2-xTB\")\natoms = calc.set_calculator(atoms, charge=0, spin_multiplicity=1)\n\n# Calculate properties\nproperties = calc.get_properties(atoms)\nenergy = properties[\"Global\"][\"Total Energy [eV]\"]\nhomo = properties[\"Orbital\"][\"HOMO [eV]\"]\nlumo = properties[\"Orbital\"][\"LUMO [eV]\"]\ngap = properties[\"Orbital\"][\"HOMO-LUMO Gap [eV]\"]\n\nprint(f\"Energy: {energy:.4f} eV\")\nprint(f\"HOMO: {homo:.4f} eV\")\nprint(f\"LUMO: {lumo:.4f} eV\")\nprint(f\"Gap: {gap:.4f} eV\")\n</code></pre>"},{"location":"user_guide/#example-7-multi-level-optimization","title":"Example 7: Multi-Level Optimization","text":"<p>Optimize structures with increasingly accurate methods.</p> <pre><code>from jfchemistry.inputs import Smiles\nfrom jfchemistry.generation import RDKitGeneration\nfrom jfchemistry.optimizers import TBLiteOptimizer, AimNet2Optimizer\n\n# Create complex molecule\nsmiles = Smiles(add_hydrogens=True)\nmol_job = smiles.make(\"CC1=CC=CC=C1C(=O)O\")  # o-Toluic acid\n\n# Generate initial conformers\ngen = RDKitGeneration(num_conformers=50, prune_rms_thresh=0.3)\ngen_job = gen.make(mol_job.output[\"structure\"])\n\n# Quick pre-optimization with GFN-FF (force field)\npre_opt = TBLiteOptimizer(method=\"GFNFF\", fmax=0.1)\npre_job = pre_opt.make(gen_job.output[\"structure\"])\n\n# Refine with GFN2-xTB (semi-empirical)\nopt1 = TBLiteOptimizer(method=\"GFN2-xTB\", fmax=0.01)\nopt1_job = opt1.make(pre_job.output[\"structure\"])\n\n# Final optimization with AimNet2 (ML potential)\nfinal_opt = AimNet2Optimizer(fmax=0.005)\nfinal_job = final_opt.make(opt1_job.output[\"structure\"])\n\n# Get lowest energy conformer\nenergies = [p[\"Global\"][\"Total Energy [eV]\"]\n            for p in final_job.output[\"properties\"]]\nmin_idx = energies.index(min(energies))\nbest_structure = final_job.output[\"structure\"][min_idx]\n</code></pre>"},{"location":"user_guide/#working-with-results","title":"Working with Results","text":""},{"location":"user_guide/#accessing-output","title":"Accessing Output","text":"<p>All JFChemistry jobs return a consistent output structure:</p> <pre><code>job_output = job.output\n\n# Structure(s) as Pymatgen Molecule/Structure objects\nstructures = job_output[\"structure\"]\n\n# File representations (XYZ or MOL format)\nfiles = job_output[\"files\"]\n\n# Computed properties (method-dependent)\nproperties = job_output[\"properties\"]\n</code></pre>"},{"location":"user_guide/#properties-dictionary-structure","title":"Properties Dictionary Structure","text":"<p>Properties are organized hierarchically:</p> <pre><code>properties = {\n    \"Global\": {\n        \"Total Energy [Eh]\": -15.234,\n        \"Total Energy [eV]\": -414.567,\n        # ... other global properties\n    },\n    \"Orbital\": {\n        \"HOMO [eV]\": -6.5,\n        \"LUMO [eV]\": -1.2,\n        \"HOMO-LUMO Gap [eV]\": 5.3,\n        # ... other orbital properties\n    },\n    # ... other property categories\n}\n</code></pre>"},{"location":"user_guide/#saving-results","title":"Saving Results","text":"<pre><code>from pymatgen.core import Molecule\n\n# Save structure to file\nstructure = job.output[\"structure\"]\nstructure.to(filename=\"output.xyz\")\nstructure.to(filename=\"output.mol\")\n\n# Save to common formats\nfrom pymatgen.io.ase import AseAtomsAdaptor\natoms = AseAtomsAdaptor.get_atoms(structure)\natoms.write(\"output.pdb\")\n</code></pre>"},{"location":"user_guide/#tips-and-best-practices","title":"Tips and Best Practices","text":""},{"location":"user_guide/#1-choosing-methods","title":"1. Choosing Methods","text":"<ul> <li>Quick screening: Use GFN-FF or GFN2-xTB</li> <li>Accurate energies: Use AimNet2 or ORB models</li> <li>Production calculations: Use GFN2-xTB \u2192 AimNet2 hierarchy</li> </ul>"},{"location":"user_guide/#2-conformer-generation","title":"2. Conformer Generation","text":"<ul> <li>Start with RDKit (10-50 conformers) for small molecules</li> <li>Use CREST for flexible molecules or thorough conformational search</li> <li>Prune similar conformers with <code>prune_rms_thresh</code> parameter</li> </ul>"},{"location":"user_guide/#3-parallelization","title":"3. Parallelization","text":"<p>JFChemistry automatically handles:</p> <ul> <li>Lists of molecules \u2192 parallel processing</li> <li>Multiple conformers \u2192 separate jobs</li> <li>Workflow distribution via jobflow</li> </ul>"},{"location":"user_guide/#4-performance-optimization","title":"4. Performance Optimization","text":"<pre><code># Good: Generate many conformers, optimize in parallel\ngen = RDKitGeneration(num_conformers=100)\nopt = TBLiteOptimizer(method=\"GFN2-xTB\")\ngen_job = gen.make(molecule)\nopt_job = opt.make(gen_job.output[\"structure\"])  # Parallelized\n\n# Better: Use CREST for efficient conformer search\ncrest = CRESTConformers(runtype=\"imtd-gc\", threads=8)\ncrest_job = crest.make(structure)\n</code></pre>"},{"location":"user_guide/#5-error-handling","title":"5. Error Handling","text":"<pre><code># Check for successful completion\nif job.output[\"structure\"] is not None:\n    # Process results\n    pass\nelse:\n    # Handle failure\n    print(\"Job failed\")\n</code></pre>"},{"location":"user_guide/#next-steps","title":"Next Steps","text":"<ul> <li>Explore the API Reference for detailed class documentation</li> <li>Check the examples directory for more use cases</li> <li>Learn about jobflow for advanced workflow features</li> </ul>"},{"location":"user_guide/#common-issues","title":"Common Issues","text":""},{"location":"user_guide/#missing-dependencies","title":"Missing Dependencies","text":"<p>Some calculators require optional dependencies:</p> <pre><code># For AimNet2\npixi install -e aimnet2\n\n# For ORB models\npixi install -e orb\n</code></pre>"},{"location":"user_guide/#crest-not-found","title":"CREST Not Found","text":"<p>Ensure CREST is installed:</p> <pre><code>pixi install  # Includes CREST by default\n</code></pre>"},{"location":"user_guide/#memory-issues","title":"Memory Issues","text":"<p>For large molecules or many conformers:</p> <ul> <li>Reduce <code>num_conformers</code> parameter</li> <li>Process molecules in smaller batches</li> <li>Increase available memory or use compute cluster</li> </ul>"}]}